<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>heguang_blog</title>
  
  <subtitle>heguang_blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-09T02:41:13.589Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>heguang123456</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20/"/>
    <id>http://example.com/2024/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20/</id>
    <published>2024-10-09T02:13:08.532Z</published>
    <updated>2024-10-09T02:41:13.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>协议protocol，网络是虚拟的，分为发送端和接收端，数据在传输中需要遵守规则，这个规则即为协 议</p><p>ISO&#x2F;OSI 开放式系统互联理论模型(7层网络模型):International Organization for  Standardization &#x2F; Open System interconnection</p><p>分别有:</p><p><strong>应用层(电商平台,社交平台,游戏)，表示层，会话层，传输层，网络层，数据链路层，物理层</strong>。</p><p>应用层(Application layer):专注于为用户提供功能，如域名有FTP，HTTP，HTTPS，DNS，DHCP，Telnet，Smtp，SSH。应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><ul><li><p>80http,443https(s为SSL加密): 域名(网址):浏览器应用的协议</p><p>  21FTP(File transform protocol):文件传输协议 负责文件传输</p><p>  53DNS:域名解析协议，将网址解析给IP地址</p><p>  68DHCP:动态获取网络地址，自动分配IP地址，IP地址即设备在网络中的唯一地址</p><p>  23Telnet: </p><p>  25Smtp: </p><p>  22SSH:</p></li></ul><p>表示层:数据加解密(保证数据传输的安全性)，数据解压缩(保证数据传输高效不会丢失)，图片&#x2F;视频编解码(解码译码方式) </p><p>会话层:sesstion会话管理(页面跳转保证登陆在线)，服务器验证用户登录，断点续传</p><p>传输层:TCP，UDP，线程，端口，socket</p><ul><li><p>socket(套接字)是通信的基石，是支持TCP&#x2F;IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口</p><p>  TCP传输控 制协议，提供一种面向连接的、可靠的、基于字节流的传输层通信协议，有流量控制和差错控制，使用TCP协议的应用比如邮件的接收和发送、文件传输、远程登录。</p><p>  需要数据稳定和完整性比较高的场景多使用TCP协议。</p><p>  UDP用户数据报协议，提供一种无连接的、高效率、低可靠性的数据传输服务，使用UDP协议的应用比如音视频聊天、在线游戏王者荣耀、工业物联网数据传输等。需要数据时效性比较高的场景多使用UDP协议。</p></li></ul><p>网络层: IP地址(IPV4，IPV6)，ARP(路由器使用,可跨路由器交换数据)，RARP</p><p>数据链路层: 有线网卡(MAC地址全球唯一)，交换机(根据MAC地址交换数据)</p><p>物理层:网线和光缆</p><p>TCP&#x2F;IP 事实标准网络模型:Trasform control 应用层，传输层，网络层，物理层 </p><p>C&#x2F;S架构Client&#x2F;Server客户服务端(任意协议) )，B&#x2F;S架构(Browser&#x2F;Server浏览器服务端):</p><ul><li><p>实现服务端的流程:<br>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/2fe816aa-9f39-4186-96a6-41769548ed3a.png" alt="截屏2024-06-04 20.33.49.png"></p><ul><li><p>关于网络字节序</p><p>  网络字节序是一种标准的数据表示方式，用于在计算机网络中传输数据。它是一种大端字节序，即高位字节存放在低地址处，低位字节存放在高地址处。与之相对的是主机字节序，它是指CPU本身使用的数据表示方式。在不同的CPU架构上，主机字节序可能是大端字节序或小端字节序。为了在网络上传输数据时能够正确解析，发送方需要将数据转换成网络字节序，接收方收到数据后再将其转换成主机字节序。在C语言中，可以使用htons、htonl、ntohs、ntohl等函数实现字节序转换。</p></li></ul></li><li><p>UDP具体实现流程</p><ul><li>加载库</li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WORD version = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">//它用于初始化 Winsock 库的版本号，使程序使用网络功能</span></span><br><span class="line">WSADATA data = &#123;&#125;;<span class="comment">//初始化WSADATA结构体里的所有变量</span></span><br><span class="line"><span class="type">int</span> err = <span class="built_in">WSAStartup</span>(version, &amp;data);<span class="comment">//初始化Winsock的使用环境,version参数指定Winsock版本，data指针存储Winsock的实现细节和启动信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != err) &#123;<span class="comment">//发生错误</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;WSAStartup fail&quot;</span> &lt;&lt; endl;<span class="comment">//调用WASGetLastError()获取具体的错误码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>校验加载的版本是否正确</li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> != <span class="built_in">HIBYTE</span>(data.wVersion) || <span class="number">2</span> != <span class="built_in">LOBYTE</span>(data.wVersion)) &#123;</span><br><span class="line"> <span class="comment">//HIBYTE和LOBYTE获取WORD类型变量的高8位和低8位字节</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;WSAStartup fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="comment">//检测Winsock库版本是否符合要求</span></span><br><span class="line">       <span class="built_in">WSACleanup</span>();</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;WSAStartup success&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>创建socket（ip地址类型，协议使用的数据格式，通信使用的协议）</li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">socket</span>(AF_INET<span class="comment">/*IPv4地址族*/</span>, SOCK_DGRAM<span class="comment">/*套接字类型*/</span>,</span><br><span class="line"> IPPROTO_UDP<span class="comment">/*UDP协议*/</span>);<span class="comment">//创建UDP套接字</span></span><br><span class="line">   <span class="keyword">if</span> (INVAILD_SOCKET == sock) &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;socket fail:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">       <span class="comment">//创建成功，返回一个SOCKET类型的套接字描述符，否则返回INVAILD_SOCKET</span></span><br><span class="line">       <span class="built_in">WSACleanup</span>();<span class="comment">//卸载库</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;socket success&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>sockaddr_in是一个结构体，是用于存储IP地址和端口号的结构体类型</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sin_family;       <span class="comment">//地址族（Address Family），也就是IP地址类型，一般设置为AF_INET</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port;<span class="comment">//16位TCP/UDP端口号，需要使用htons()进行字节序转换</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;    <span class="comment">//32位IP地址，需要使用inet_addr()进行转换，或者直接赋值为ADDR_ANY</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero;  <span class="comment">//填充0，使sockaddr_in和sockaddr具有相同的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>绑定ip和端口号（告诉操作系统这个应用进程使用的哪个端口号和哪个ip）</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addrServer;</span><br><span class="line"> addrServer.sin_family = AF_INET;<span class="comment">//将sin_family设置为IPv4地址</span></span><br><span class="line"> addrServer.sin_port = <span class="built_in">htons</span>(<span class="number">2233</span>);         <span class="comment">//将主机字节序转换成网络字节序(大端小端)</span></span><br><span class="line"> addrServer.sin_addr.S_un.S_addr = ADDR_ANY;<span class="comment">//接收所有的ip地址</span></span><br><span class="line"> <span class="comment">//如果使用特定的ip地址，可以使用inet_addr()函数将字符串类型的IP地址转换成32位的整数</span></span><br><span class="line"> <span class="comment">//IP地址有两种类型，十进制四等分字符类型&quot;192.168.3.222&quot;</span></span><br><span class="line"> <span class="comment">//ulong类型</span></span><br><span class="line"> err = <span class="built_in">bind</span>(sock<span class="comment">/*要绑定的socket*/</span>, (sockaddr *) &amp;addrServer<span class="comment">/*指向结构体addrServer的指针，该结构体包含要绑定的地址*/</span>, </span><br><span class="line"> <span class="comment">/*结构体addrServr的大小*/</span><span class="built_in">sizeof</span>(addrServer));<span class="comment">//将一个socket与一个本地地址绑定</span></span><br><span class="line"> <span class="keyword">if</span> (SOCKET_ERROR == err) &#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;bind fail:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">     <span class="comment">//绑定失败，输出错误信息并关闭套接字，释放资源；</span></span><br><span class="line">     <span class="comment">//关闭套接字</span></span><br><span class="line">     <span class="built_in">closesocket</span>(sock);</span><br><span class="line">     <span class="comment">//卸载库</span></span><br><span class="line">     <span class="built_in">WSACleanup</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果调用成功，则输出绑定成功的提示信息</span></span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;bind success&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>接收数据与发送数据</li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Socket发送给Servr。在Servr端，需要通过读取Socket接收客户端发送的数据，</span></span><br><span class="line"><span class="comment">//并进行处理。处理完成后，Servr可以通过Socket发送回应数据给客户端。</span></span><br><span class="line"> <span class="type">int</span> nRecvNum = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> nSendNum = <span class="number">0</span>;</span><br><span class="line">   <span class="type">char</span> recvBuf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="type">char</span> sendBuf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   sockaddr_in addrClient = &#123;&#125;;<span class="comment">//初始化addrClient结构体变量的成员</span></span><br><span class="line">   <span class="type">int</span> size = <span class="built_in">sizeof</span>(addrClient);<span class="comment">//获取addrClient的大小</span></span><br><span class="line">   <span class="type">char</span> ip[<span class="number">20</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//recvfrom()函数从指定的套接字(socekt)接收数据，</span></span><br><span class="line">    <span class="comment">//接收到的数据被存储到recvBuf中，缓冲区的大小为sizeof(recvBuf)，获取发送方的IP地址和端口号</span></span><br><span class="line">    <span class="comment">//这些信息会被存储在sockaddr_in类型的addrClient变量中，最后这个函数返回接收到的数据的字节数</span></span><br><span class="line">    nRecvNum = <span class="built_in">recvfrom</span>(sock, recvBuf, <span class="built_in">sizeof</span>(recvBuf), <span class="number">0</span>, (sockaddr *) &amp;addrClient, &amp;size);</span><br><span class="line">       <span class="keyword">if</span> (nRecvNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//接收成功,打印接收到的数据</span></span><br><span class="line">           <span class="comment">// 把ulong类型的ip转换成字符串类型的ip</span></span><br><span class="line">           <span class="built_in">inet_ntop</span>(AF_INET<span class="comment">/*地址族ipv4或ipv6*/</span>, (<span class="type">void</span> *) &amp;addrClient.sin_addr.S_un.S_addr<span class="comment">/*一个指向IP地址的指针*/</span>,</span><br><span class="line">            ip<span class="comment">/*指向存储转换结果的缓冲区的指针*/</span>, <span class="built_in">sizeof</span>(ip)<span class="comment">/*缓冲区的大小*/</span>);</span><br><span class="line">           <span class="comment">//inet_ntop将ip地址从二进制转换为文本</span></span><br><span class="line">           cout &lt;&lt; ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; recvBuf &lt;&lt; endl;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == nRecvNum) &#123;</span><br><span class="line">           <span class="comment">//连接断开</span></span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;connection closed&quot;</span> &lt;&lt; endl;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//接收失败</span></span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;recvfrom fail:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">           <span class="comment">//发送错误信息并退出</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5、发送数据</span></span><br><span class="line">       <span class="built_in">gets</span>(sendBuf);<span class="comment">//客户端输入数据，服务端显示数据</span></span><br><span class="line">       nSendNum = <span class="built_in">sendto</span>(sock<span class="comment">/*套接字描述符*/</span>, sendBuf<span class="comment">/*发送的数据缓冲区*/</span>, </span><br><span class="line">       <span class="built_in">sizeof</span>(sendBuf)<span class="comment">/*缓冲区大小*/</span>, <span class="number">0</span><span class="comment">/*一般不需要设置*/</span>, </span><br><span class="line">       (sockaddr *) &amp;addrClient<span class="comment">/*目标地址*/</span>, size<span class="comment">/*地址长度*/</span>);</span><br><span class="line">       <span class="keyword">if</span> (SOCKET_ERROR == nSendNum) &#123;<span class="comment">//nSendNum实际发送的字节数，出现错误了</span></span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;sendto fail:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;<span class="comment">//发送错误信息</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试:</p><p>1、打开服务器</p><p>2、打开客户端</p><p>3、客户端先输入数据，回车</p><p>——结果在服务端显示客户端刚刚输入的数据</p><p>4、在服务端输入数据，回车</p><p>——在客户端显示刚刚输入的数据</p><p>注意:客户端先发送</p><p>发送的时候写明ip地址（只有一个，不能写任意和端口号） </p><p>ip决定发送给哪台设备，端口号决定发送给哪个应用</p><p>ip地址总改变：DHCP协议能在局域网内动态分配ip地址。私人网络固定位置ip地址，重复概率高，因此需要私人ip地址管理；公共网络人多IP率极低。</p><p>为什么客户地址不需要绑定ip地址和端口号: 首先，若客户端没有绑定，操作系统会自动分配(DHCP协议)</p><p>两个网卡在同时工作，自动连接时可能出问题：既连接了WIFI又连接有线网卡，客户端与服务端的端口号必须不同</p><ul><li><p>数据包在传输过程中的变化过程</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_11.40.26.png" alt="截屏2024-06-07 11.40.26.png"></p><ul><li>应用层负责原数据与用户数据的管理</li><li>UDP协议: 基于报文段传输，传输UDP数据包 ，以便于网络层将其传输到目标主机。传输层协议还可以通过端口号标识不同的应用程序，以便于网络层将数据传输到正确的应用程序。检查UDP头</li><li>ip数据报: 从哪个设备来到哪个设备去，传输ip数据包，它能够使得不同计算机之间通过互联网实现通信，检查IP头</li><li>帧: 解析出来目的mac是否本设备mac、将ip数据包网上传递,加入帧头与CRC校验</li><li>从上到下“层层加码”，从下往上“层层解码”，实现数据包的传输</li></ul></li><li><p>单播、组播和广播</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_13.14.10.png" alt="截屏2024-06-07 13.14.10.png"></p><ol><li><p>单播(unicast)：在数据传输中，IP协议下的TCP&#x2F;IP模型。针对单一的目标接受者(一对一)，通信方式效率高，定向发送到特定的网络地址或设备。如电子邮件、Web浏览、文件传输等。</p><ol><li>特点：<ol><li><strong>目标明确</strong>：发送者知道确切的接收者地址，数据包不会广播出去。</li><li><strong>带宽效率</strong>：由于只发送一次，网络资源不会被无效的数据包占用。</li><li><strong>安全性</strong>：提高了信息的保密性，因为数据只能由特定接收者解密和访问。</li><li><strong>延迟较低</strong>：相比广播或多播，单播的传输延迟通常更小。</li></ol></li></ol></li><li><p>组播(multicast): 是一种在计算机网络中高效传输数据的技术，特别适用于需要将信息发送给多个接收者的情况，而不仅仅是一个一对一的通信。在组播中，数据包只发送一次，但它会被网络中的所有预定义的接收者节点接收，这样就节省了带宽资源，提高了通信效率。类比微信群聊</p><ol><li>使用场景:<ol><li>IP组播：IP协议支持的组播，允许数据流定向到一组网络地址，而不是每个单个地址。</li><li>RTP（Real-Time Transport Protocol）组播：常用于视频会议、网络直播等实时应用，多个接收者共享同一流媒体源。</li><li>DNS查询：DNS服务器使用组播来回应多个请求。</li><li>PIM（Protocol Independent Multicast）协议：用于建立和维护组播树，确保高效的数据转发。</li></ol></li></ol></li><li><p>广播(boardcast)：在数据传输中主要用于在一个网络段内的所有设备之间发送消息。它是一种单向通信，信息会从发送者直接发送到网络中的每一个节点，而不仅仅是目标节点。</p><ol><li><p>使用场景：</p><ol><li><strong>信息通知</strong>：当有紧急或通用的信息需要传达给所有连接的设备时，如系统更新、广播寻址等。</li><li><strong>设备发现</strong>：在局域网（LAN）中，新加入的设备可能会使用广播来寻找网络配置信息，如IP地址分配。</li><li><strong>组播（Multicast）的前奏</strong>：虽然组播是更为精确的一种发送方式，但广播经常作为其发现和初始连接的一部分。</li></ol></li><li><p>缺点:</p><p> 比如可能导致网络拥塞，因为每个节点都会接收到消息，且没有路由选择，消息可能会无限传播。因此，在现代网络设计中，广播通常被限制在本地网络中，并且通过VLAN（虚拟局域网）或者子网划分来控制其范围，以减少对全局网络的影响。</p></li></ol></li></ol></li><li><p>ARP协议</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_13.19.24.png" alt="截屏2024-06-07 13.19.24.png"></p><ul><li>ARP（Address Resolution Protocol）是网络层的一个TCP&#x2F;IP协议，主要用于将IP地址映射到物理MAC地址上。在一个IPv4网络中，当数据包在网络中传输时，每个设备需要知道发送或接收数据的其他设备的MAC地址才能实际通信。</li><li>已知目的ip地址不知道目的mac地址，无法发送信息，此时，使用ARP协议获取目的mac。<ul><li><p>工作原理:</p><ol><li><strong>请求-响应模式</strong>：当一个设备需要了解某个IP地址对应的MAC地址时，它会发送一个ARP请求广播到网络中。这个请求包含目标IP和发送者的MAC地址。</li><li><strong>目标设备回应</strong>：拥有目标IP地址的设备接收到请求后，如果它是目标，就会回复一个ARP响应，其中包含了它的MAC地址和目标的IP地址。</li><li><strong>缓存更新</strong>：发送者收到响应后，会将目标的IP到MAC的映射添加到自己的ARP缓存中，以便后续快速查找.</li></ol><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_15.21.37.png" alt="截屏2024-06-07 15.21.37.png"></p></li></ul></li></ul></li><li><p>ARP代理</p><ul><li><p>ARP（Address Resolution Protocol）代理是一种网络技术，它主要用于简化局域网内的地址解析过程。在传统的ARP协议中，当一个设备需要发送数据包到另一个设备时，它会先查找目标设备的IP地址对应的物理地址（MAC地址），这个过程是单对单的。然而，如果有多台设备共享同一个网络，并且这些设备都需要通过代理进行通信，那么ARP代理就会介入。</p></li><li><p>主要作用:</p><ol><li><strong>集中管理</strong>: 代理服务器存储了网络中的IP-MAC映射关系，所有设备的请求都发送给代理，代理再将正确的MAC地址返回给请求者，减少了设备之间的直接通信。</li><li><strong>安全性</strong>: 代理可以防止未经授权的ARP欺骗攻击，因为它控制着网络上ARP表项的更新，确保信息的准确性和完整性。</li><li><strong>负载均衡和扩展性</strong>: 对于大型网络，通过ARP代理，可以将ARP查询的负担分散到多个服务器，提高网络性能并支持更多的设备接入。</li><li><strong>易于管理</strong>: 代理提供了集中化的网络配置和审计功能，管理员可以通过代理对整个网络的地址解析进行统一管理和监控。</li></ol></li></ul></li><li><p>免费ARP</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_15.30.42.png" alt="截屏2024-06-07 15.30.42.png"></p><ul><li>免费ARP（ gratuitous ARP ），也称为 Gratuitous Address Resolution Protocol，是一种主动的协议行为，主要用于在网络中更新或确认网络设备的IP地址和MAC地址映射关系。当一台设备更改了它的IP地址，或者刚连接到网络时，为了确保其他设备能够正确地找到它的物理位置，这台设备会发送一个免费ARP请求。老化机制: 长时间无用数据会被删除，可重新通过ARP协议获取mac地址</li><li>工作原理:<ol><li><strong>地址更改后的通告</strong>：如果一个设备更换了IP地址，它会发送一个免费ARP包，包含新的IP地址，询问是否有其他设备已经分配了相同的地址。</li><li><strong>初始化网络连接</strong>：新连接的设备在首次接入网络时，也会发送免费ARP，告知其他设备它现在占用的IP地址。</li><li><strong>冲突检测</strong>：当多个设备尝试用同一IP地址进行通信时，可能会收到多个免费ARP响应，这时可以通过对比MAC地址确认哪台设备是真正的所有者。</li></ol></li><li>作用:<ul><li>免费ARP对于网络中的IP地址冲突检测、负载均衡以及故障排查非常有用，它有助维护网络中IP地址与物理地址的一致性。不过，由于其主动发送，如果不加以控制，可能会造成网络流量的增加。</li></ul></li></ul></li><li><p>DNS协议</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_15.30.15.png" alt="截屏2024-06-07 15.30.15.png"></p><p>  域名解析（Domain Name Resolution, DNS）是互联网中一项基本的服务，它将人类可读的域名（如 <a href="http://google.com/">google.com</a>）转换成计算机能够理解的IP地址（如172.217.167.168）。当我们在浏览器中输入一个网址，DNS服务器扮演着关键角色，它负责查找并提供相应的IP地址，使得我们的请求能够准确地找到对应的网站服务器。</p><ul><li>工作原理<ol><li>用户设备向本地的DNS缓存（可能在路由器或操作系统中）发送查询。</li><li>如果缓存中有该域名的记录，直接返回IP地址。</li><li>如果没有，查询会发送到根DNS服务器，请求获取顶级域名（.com、.org等）的授权服务器列表。</li><li>接下来，查询会递归地发送给权威域名服务器，直到找到正确的服务器，并获取到所需的IP地址。</li><li>最终，IP地址被返回给用户设备，连接过程开始。</li></ol></li></ul></li><li><p>路由数据转发过程</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_17.52.57.png" alt="截屏2024-06-07 17.52.57.png"></p><p>  路由数据转发是网络通信中的关键机制，它确保数据包从源地址到目标地址的高效传输。在路由器中，这个过程主要包括以下几个步骤：</p><ol><li><p><strong>接收到数据包</strong>：路由器在数据链路层接收到一个数据包，通常包含源IP地址和目标IP地址。R1端口1接收</p><p> <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_17.59.42.png" alt="截屏2024-06-07 17.59.42.png"></p></li><li><p><strong>检查目的地址</strong>：路由器会解析数据包的IP头部，查看目标IP地址是否与自身的路由表相符。如果目的地是本地接口或已知的下一个路由器，就直接转发。R2端口2转发</p></li><li><p><strong>查找路由表</strong>：如果目标地址不在本地路由表中，路由器会根据路由协议（如OSPF、BGP等）查找最佳路径。路由表定义了网络拓扑结构和下一跳地址。</p></li><li><p><strong>选择路径</strong>：路由器会基于诸如带宽、延迟、可靠性等因素计算出一条最优的路径，通常是距离最短或成本最低的路径。</p></li><li><p><strong>更新数据包头部</strong>：路由器会在数据包头部插入新的下一跳IP地址，并可能改变TTL（Time to Live，生存时间）字段，以防止无限循环转发。下一跳mac地址</p></li><li><p><strong>转发数据包</strong>：路由器将修改后的数据包发送到下一跳地址，这个过程可能需要通过多个路由器的接力传递。</p></li><li><p><strong>递归转发</strong>：如果数据包最终到达的是另一个网络，这个过程可能会重复，直到数据包达到目标网络。</p></li><li><p><strong>交付到目的地</strong>：数据包最终被目标设备（可能是另一台路由器或终端设备）接收，然后通过IP分片和重组返回给上层应用程序。</p></li><li><p>交换器不能转发（数据链路，物理），路由器（数据链路，物理，网络）可以转发：ip地址不变，mac地址在变。交换机只有mac地址。</p></li></ol></li><li><p>TCP协议特点</p><p>  可靠的，面向连接的，基于字节流的</p></li><li><p>ip协议格式</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-07_18.06.52.png" alt="截屏2024-06-07 18.06.52.png"></p><p>  固定部分: 32位字节，一行为4字节，共五行；即ip头总长度为20~60，剩下40为可变部分，存放数据应为4的倍数，溢出应填满，必须占满4字节倍数的空间；如WIFI密码的存放。</p><p>  版号表示IPV4与IPV6的不同；首部长度为表示的是ip头长度；总长度即数据部分的长度；标识即事件同时触发的事件处理顺序；标志+片偏移，偏移保证数据部分在分成多段部分仍能按照原有数据的顺序合成后数据的完整性</p><p>  UDP特点总结：</p><p>  1、面向非连接，接收数据的时候。一个socket可以接受任意客户端发回来的数据，可以是一对一，可以是一对多（广播）</p><p>  2、通讯方式：数据报文的通讯方式，数据包不可拆分</p><p>  3、传输效率高（跟TCP对比）</p><p>  4、会产生丢包，没有校验检查，会出现乱序</p><p>  练习题</p><ol><li>210.33.5.68&amp;255.255.255.218 &#x3D; 210.33.5.0</li><li>子网1:20.0.0.0 子网2:20.0.1.0 ……子网63:20.0.63.0 有效主机位8位，2位主机位，6位计算</li><li>每个网络8个主机位，用3位表示五个子网，剩下5位网络号分配给子网的主机，新子网掩码位255.255.255.224，后3位替代为110 1111</li></ol><p>  子网1:211.168.10.1～211.168.10.31；子网2为211.168.10.32～211.168.10.63；子网3为211.168.10.64<del>211.168.10.95;子网4为211.168.10.96</del>211.168.10.127;子网5为211.168.10.128~159</p><ol><li><p>ip地址为10.100.122.38，子网掩码为255.255.248.0；网络部分占24，主机占8，划分出2^13，255有8个+248的5个，每个子网除广播地址和网络地址外有2^11个地址，</p><p> 前1个: 10.0.0.0~10.0.0.255.        网关:    10.100.12.1           广播:10.100.12.255.</p><p> 前2个: 10.0.8.0.~10.0.8.255. 网关:    10.100.16.1           广播:10.100.16.255</p><p> 前3个:10.0.16.0~10.0.16.255网关:        10.100.20.1           广播:10.100.20.255</p><p> 后1个: 10.245.255.0~10.245.255.255;网关:           10.100.224.1    广播: 10.100.224.255 </p><p> 后2个: 10.243.255.0~10.243.255.255网关:     10.100.232.1          广播:10.100.232.255</p><p> 后3个10.255.255.0~10.255.255.255网关:   10.100.240.1           广播:10.100.240.255</p><ul><li><p>服务端与客户端编写流程</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-12_12.44.22.png" alt="截屏2024-06-12 12.44.22.png"></p><ul><li>客户端发送链接，服务端接受链接，服务端通过监听接受链接，然后服务端发送数据，客户端接受数据，服务端</li></ul><p>  打印出客户端的IP才是连接成功<br>  需要创建出两个SOCKET，第一个sock用来接收链接，第二个sockListen用来收发数据，第一个sock用于获取IP和端口号，socket即通信单位。<br>  接收链接说明accept是阻塞函数，此时程序属于等待链接的状态，连接成功后才能接收数据</p></li></ul></li></ol></li><li><p>ip地址分类</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_154538.png" alt="屏幕截图 2024-06-13 154538.png"></p><p>  ipv4地址类型如图：127.255.255.255为十进制四等分的ip地址，每一段转换为二进制数字占8位，所以范围为0~255。通过ip分类可得不同作用的ip，可记忆ip开头处区分：A为1.0.0.0（0000 0001）；B为128.0.0.0（1000 0001）；C类为192.0.0.0（1100 0000）；D类为224.0.0.0（1110 0000）；E类为240.0.0.0（1111 0000）。常见出题为ABC类</p><p>  家里的ip地址一般为C类，A类的公网一般用作服务器，127.0.0.0~127.255.255.255均可用作回环测试（即自己主机为服务器同时为客户端）</p><p>  IPv4地址通常有32位，分为网络地址（前24位）和主机地址（后8位）</p></li><li><p>子网掩码</p><p>  子网：它将一个大的IP地址空间划分为多个较小的、更易于管理和使用的部分。目的是避免IP地址的浪费，提高网络效率，控制广播域，并实现网络的层次结构设计，使得大型网络能够被组织成易于管理的层级。</p><p>  子网掩码：每个子网都有一个对应的子网掩码，它可以用来识别网络部分和主机部分。通过与IP地址进行按位与操作，可以确定一个IP地址是属于哪个子网。</p><p>  所有设备需要通过IP地址与其他子网的设备进行通信，需要先发送给路由器，然后由路由器转发，其他设备通过路由器所查看到的该设备的ip地址并非该设备的原IP地址，而是IP地址与</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_161026.png" alt="屏幕截图 2024-06-13 161026.png"></p><p>  网络号+主机号&#x3D;&#x3D;主机的网络地址（对外的IP地址）主机号会被隐藏，网络号&#x3D;&#x3D;子网掩码按位&amp;原IP地址。如判断双方是否处于同一子网下，只需计算出双方的网络地址比对，如果相同，则同于同一子网，反之，不在同一子网内。</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_162633.png" alt="屏幕截图 2024-06-13 162633.png"></p></li></ul><p>记忆技巧：A类1个255，B类2个255，C类3个255</p><p>网络地址用于区分不同网络，而主机地址则用于识别同一网络内的设备。这种连续的“1”的设置确保了网络寻址的效率和层次结构，使得路由器能够正确地路由数据包到相应的网络。</p><p>不同的IP地址分类可得不同的默认子网掩码，然后进行计算网络地址</p><ul><li><p>网关</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_163804.png" alt="屏幕截图 2024-06-13 163804.png"></p><p>  主机号为0的IP地址即网关，由图中看出此时的IP地址已被网关占用，无法被分配。</p><ul><li>网关功能<ol><li><strong>地址转换</strong>：网关可以帮助内部网络的设备使用私有IP地址与外部网络通信，通过NAT技术（网络地址转换）隐藏了内部网络的结构和IP地址。</li><li><strong>安全过滤</strong>：网关可以提供防火墙功能，阻止未经授权的访问和恶意流量。</li><li><strong>协议转换</strong>：对于不同协议的网络设备，网关可能需要进行协议转换，例如从TCP&#x2F;IP转换到PPP或者从IPX&#x2F;SPX到TCP&#x2F;IP。</li><li><strong>路由选择</strong>：网关能够根据配置进行路由决策，选择最优路径将数据发送到目的地。</li></ol></li></ul></li><li><p>广播地址</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_165439.png" alt="屏幕截图 2024-06-13 165439.png"></p><p>  主机号全0为网关地址，主机号全1为直接广播地址</p><p>  有限广播应用：红蜘蛛直播，组播，设备发现</p><p>  有限广播和直接广播的区别： </p><p>  作用域不同：直接广播的广播域可以是不同（指定）的广播地址，有限广播的广播域只能是本网广播的广播地址</p><p>  二进制位数不同：直接广播的广播地址是主机号全为1，有限广播的广播地址指的是32为全为1</p><ul><li><p>非默认子网掩码</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_171229.png" alt="屏幕截图 2024-06-13 171229.png"></p><p>  比默认子网掩码的1位数多，如图</p></li><li><p>子网划分常见问题（做题转换）</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_171848.png" alt="屏幕截图 2024-06-13 171848.png"></p></li><li><p>以太网帧结构</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-13_175543.png" alt="屏幕截图 2024-06-13 175543.png"></p><p>  MTU：一个网络包的最大长度，以太网中一般为1500字节</p><p>  MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度</p></li></ul><p>  TCP协议使用的是send和recv收发数据</p><p>  UDP协议使用的是sendto和recvfrom收发数据</p><p>  TCP三次握手原则</p></li><li><p>发广播</p><p>  只有UDP才能发广播，把发送地址填直接广播地址即自己的IPV4地址。有限广播地址即255.255.255.255。有限广播需要申请广播权限setsockopt()。多网卡情况下，有限广播地址无法确保是所需地址发送，如果想精确某个局域网内地址，可以先关闭WIFI的链接（只适用于课程教学的临时解决方案）</p></li><li><p>阻塞和非阻塞</p><p>  socket默认是阻塞的，导致接收和发送也是阻塞的。</p><ul><li><p>非阻塞：</p><ol start="2"><li>相比之下，非阻塞I&#x2F;O允许线程在发起I&#x2F;O请求后不立即等待结果，而是立即返回，然后继续执行其他任务。如果I&#x2F;O尚未完成，线程会立即返回并设置一个标志或事件，表示可以稍后再检查结果。这样可以避免线程阻塞，提高系统的并发性能和响应速度。</li></ol></li><li><p>阻塞：</p><ol><li>当一个线程执行I&#x2F;O操作（如读取或写入文件、网络套接字等）时，如果数据不可用，该线程会暂时停止执行（即“阻塞”），直到数据准备好或操作完成。这意味着在等待期间，其他任务无法继续运行，可能会导致系统性能下降，特别是当大量线程同时等待同一资源时。</li></ol></li></ul><p>  接收</p><p>  阻塞：事件发生立刻知道，因为事件挂起了，所以阻塞过程中不消耗CPU</p><p>  非阻塞：不能第一时间发现事件发生，非阻塞的过程中一直消耗CPU</p><p>  发送：</p><p>  阻塞：当发送缓冲区不足够大的时候，阻塞发送就是等到空间足够大再发送</p><p>  非阻塞：有多少空间发多少数据，剩余数据程序自己处理</p><p>  选择使用哪种模式取决于以下因素：</p><ul><li>是否能接受短暂的延迟：阻塞I&#x2F;O 对于短期等待可能是合适的。</li><li>并发性能：如果应用需要处理大量并发连接，非阻塞I&#x2F;O 可以提高效率。</li><li>程序复杂性：非阻塞I&#x2F;O 需要更多的错误处理和事件驱动编程技巧。</li></ul></li><li><p>发送和接收缓冲区</p><p>  在共同使用（!&#x3D;）随意使用的内核空间中；一个socket分成接收缓冲区和发送缓冲区，在代码里实现的recvBuf和sendBuf是在用户空间分配的。当操作系统接收数据后，则会将数据写入接收缓冲区，当调用recvFrom函数后则是将接收缓冲区里的数据拷贝到用户空间的recvBuf里面，所以阻塞实际上是接收缓冲区没有数据，recvBuf在等待数据的传输。同理，发送数据就是sendBuf将数据传输到发送缓冲区，然后由操作系统负责向外传输。</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-14_203552.png" alt="屏幕截图 2024-06-14 203552.png"></p><p>  打印发送缓冲区和接收缓冲区的大小getsocketopt()；65536&#x3D;64*1024字节，即64KB，就是说一次发送的大小不能超过64KB，若超过了，剩下的数据无法显示，即数据丢失。实际上，并没有64KB大，因为传输层中，有MSS限制传输数据的大小，所以，为了传输数据加快，不要发送过大数据。</p></li><li><p>内存分配</p><p>  进程4G虚拟内存，4GB的虚拟内存并不是说实际可用的物理内存就是4GB，而是指进程能够使用的最大地址空间。当进程运行时，操作系统会动态地管理这些内存，将常用的部分加载到物理内存，不常用的则保留在磁盘的交换空间。这种虚拟内存机制使得进程可以在需要时扩展其可用的内存，超出物理内存的限制。是由物理内存映射到磁盘得来的虚拟内存</p><p>  （1）大小的虚拟（2）地址的虚拟</p><p>  虚拟内存空间分为0<del>2G，2</del>4G；0<del>2G属于用户空间，对于操作系统而言，用户就是进程，故这部分虚拟内存单独给进程使用，进程单独使用，相互不能乱访问。2</del>4G属于内核空间，共同使用。</p></li><li><p>TCP协议的连接服务器</p><p>  inet_pton()将网络地址转换，connnect返回是int值，如果用socket去接收返回值，系统会报错：在一个非法的套接字上进行发送数据，能接收成功的原因是socket本质上是UINT_PTR经过typedef来的，所以应该定义一个新的int变量接收connet的返回值。</p><p>  错误码分类：INVALID_SOCKET和SOCKET_ERR，只有创建socket时使用了INVALID_SOCKET，其他函数基本报错误码时是SOCKET_ERR，SOCKET_ERR本质上是-1的宏定义，而INVALID_SOCKET则是(~0)的宏定义。</p><p>  连接失败时报错地址无效，不是IP地址写错了，是IP地址格式错误（例如多加空格），</p><p>  发送数据溢出内存：后面发送数据得完全覆盖前面数据，即每次发送数据得是整个空间（例2048）的大小。不能是每次发送一个字符串的大小，如果需要每次发送一个字符串大小，那么每次发送完需要清理发送空间，将上一次数据清理</p></li><li><p>为什么TCP协议可靠</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_09.09.43.png" alt="截屏2024-06-17 09.09.43.png"></p><p>  复习：UDP协议头&#x3D;<strong>源端口(Source port)+目的端口(Destination port)+数据长度(Data length)+校验和(Checksum)+UDP头部</strong></p><p>  TCP&#x3D;<strong>源端口号（Source Port）和目的端口号（Destination Port)+序号（Sequence Number, Seq)+确认号（Acknowledgment Number, Ack）+数据偏移（Data Offset）+ 标志（Flags）+窗口（Window）+校验和（Checksum）+ 紧急指针（Urgent Pointer）+可选项（Options）+填充（Padding）</strong></p><ul><li>TCP头<ol><li><strong>源端口号（Source Port）和目的端口号（Destination Port）</strong>：每个连接都有唯一的源和目的端口号，用于标识发送和接收数据的应用进程。</li><li><strong>序号（Sequence Number, Seq）</strong>：用于标识数据包的顺序，接收者会根据序列号确认数据是否完整。触发按顺序触发，到达后按顺序排号，保证不乱序 </li><li><strong>确认号（Acknowledgment Number, Ack）</strong>：接收者回应的下一个期望接收到的序列号，用于确认已成功接收的数据段。一个序号对应一个确认号，没回复确认号则代表数据未收到。</li><li><strong>数据偏移（Data Offset）</strong>：指示头部长度，以32位字为单位计算的，包含了标志、窗口、校验和等字段的位置。（确保）</li><li><strong>标志（Flags）</strong>：包括URG（紧急指针），ACK（确认），PSH（推动），RST（重置连接）前提是已经连接过，SYN（同步序列号用于建立连接），FIN（结束连接）。每个标志位占一个二进制位，1代表启用，0代表关闭，使用紧急指针功能需标志URG为1</li><li><strong>窗口（Window）</strong>：用于流量控制，通知发送方接收缓冲区剩余空间。 </li><li><strong>校验和（Checksum）</strong>：对头部进行校验，保证数据的正确性。</li><li><strong>紧急指针（Urgent Pointer）</strong>：如果存在紧急数据，则包含在此，指示紧急数据的起始位置。</li><li><strong>可选项（Options）</strong>：早期版本的TCP，可能包含一些可选的扩展信息，但现代TCP很少使用。</li><li><strong>填充（Padding）</strong>：如果头部长度不是整数倍的4字节，填充为0。</li></ol></li></ul></li><li><p>ACK机制</p><p>  如图，数据(序号&#x3D;1…100)从客户端发送到服务端，服务端标志确认码ACK为1，发送ack&#x3D;101，然后客户端继续发数据(序号&#x3D;101…200)，服务端标志确认码ACK为1，发送ack&#x3D;201。</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_10.19.17.png" alt="截屏2024-06-17 10.19.17.png"></p></li><li><p>产生丢包问题启用超时重传</p><ul><li>发送中丢包<ul><li>发送方设置一个超时计时器：当数据包被发送出去后，计时器开始计时。超时时间从发送数据后开始，接收数据时结束。</li><li>等待确认：如果在超时时间内收到确认，计时器会被重置。如果没有收到确认，超时计时器到期。</li><li>当超时计时器超时，发送方会重新发送之前的数据包。这会继续重复，直到接收到确认或者达到最大重传次数</li></ul></li><li>接收中丢包<ul><li>发送数据成功，但是在发送ACK确认阶段丢失，继续重复发送，直到接收到确认或者达到最大重传次数。重复收到的包丢弃，但是仍然会把ACK发送。</li></ul></li></ul></li><li><p>TCP传输控制协议（三次握手）</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_10.52.55.png" alt="截屏2024-06-17 10.52.55.png"></p><ul><li>最初，客户端和服务端都处于CLOSE状态，先是服务端主动监听端口，处于LISTEN状态</li><li>然后客户端标志SYN(第一次握手)置1位，建立连接connect阻塞函数，发送序号seq&#x3D;x，之后处于发送SYN-SEND状态</li><li>服务端通过accpet阻塞函数收到发起的连接，返回SYN和ACK（第二次握手），发送序号seq&#x3D;y并且ack&#x3D;x+1客户端的SYN，之后处于SYN-RCVD状态，</li><li>客户端connect返回收到服务端发送的SYN和ACK之后，发送ACK的ACK(第三次握手)，之后处于ESTABLISHED状态，因为他一发一收成功了，发送序号seq&#x3D;x+1，ack&#x3D;y+1。</li><li>服务端accept返回收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。</li></ul><p>  问题与思考：</p><p>  1.为什么三次握手的次数是三次：</p><ul><li>防止“半开”连接：第一次握手后，如果服务器没有回应，客户端可能会认为连接已经建立，但服务器可能没有收到，这样会造成资源浪费。三次握手确保双方都确认收到了对方的请求。</li><li>顺序确认：第二次握手中服务器回应的是SYN+ACK，这意味着服务器不仅确认了收到，还准备好了接收，防止了客户端立即发送数据导致的数据混乱。</li></ul><ol><li>整个详细流程的复述</li></ol></li><li><p>四次挥手（断开连接）</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.18.53.png" alt="截屏2024-06-17 13.18.53.png"></p><ul><li>主动方打算关闭连接，此时会发送一个TCP首部FIN（第一次挥手）标志位被置为1的，状态转为FIN_WAIT_1，序号seq&#x3D;u,ack&#x3D;v+1。</li><li>被动方收到该报文（第二次挥手）后，就向主动方发送ACK应答报文，接着被动方进入CLOSED_WAIT状态，序号seq&#x3D;v+1,ack&#x3D;u+1，</li><li>主动方收到被动方的ACK应答报文之后，之后进入FIN_WAIT_2状态</li><li>等待被动方处理完数据后，也向主动方发送FIN（第三次挥手）报文，之后被动方进入LAST_ACK状态，确认数据处理完再发FIN，序号seq&#x3D;v+2，ack&#x3D;u+1，发送ACK确认</li><li>主动方收到被动方的FIN报文（第四次挥手）后，回一个ACK应答报文，之后进入TIME_WAIT状态，序号seq&#x3D;u+1，ack&#x3D;v+3，</li><li>被动方收到了ACK应答报文后，就进入了CLOSED状态，至此被动方已经完成连接的关系</li><li>主动方在经过2MSL一段时间后，自动进入CLOSED状态，至此主动方也完成连接的关闭(如果被动方又发了个FIN说明ACK丢包，反之什么信息都没有发送没有丢失)2MSL：两个最大段生存时间（主动方的ACK过去以及等待下一个FIN来的时间段）如果在这个时间段里，被动方又发了个FIN，主动方发回ACK，则2MSL重新计时</li></ul><p>  问题与思考：</p><ol><li>四次挥手详细流程的复述(seq和ack值的变化，双方状态的变化，流程的讲解)</li><li>为什么被动方在收FIN后没有立刻回复FIN的到来：因为此时被动方的数据还没处理完，要等数据处理完后再给主动方发送数据FIN确认ACK</li><li>主动方在发完ACK后要等待2MSL再关闭：等2MSL是为了确定自己的ACK有没有丢失，如果在2MSL时间内又收到了FIN，那么就需要主动方重新发送ACK确认，如果在2MSL时间内，被动方没有发送FIN，说明主动方的ACK并未丢失，没有出发超时重传</li></ol></li><li><p>往返时延</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.18.13.png" alt="截屏2024-06-17 13.18.13.png"></p><p>  这个过程通常包括发送数据、在网络中传输、接收确认以及可能的网络拥塞控制。RTT是衡量网络延迟和响应时间的重要指标，特别是在实时应用如语音通话（交流是否流畅）、视频会议（音画同步）和在线游戏(游戏里的延迟)等中，较低的RTT意味着更流畅的交互。</p><p>  链路的传播时间即信号在光缆传播的时间（物理实体）</p><p>  末端系统的处理时间（设备处理数据的时间）</p><p>  路由器的缓存中的排队和处理时间（硬件设备以及网络数据的丢失或拥堵）</p><ul><li><p>影响RTT的因素</p><ol><li>网络距离：数据传输经过的物理链路长度会直接影响RTT。</li><li>网络带宽：高带宽可以减少数据传输时间，但不一定能减小RTT。</li><li>网络设备和节点：路由器、交换机的处理能力、队列深度等都会影响RTT。</li><li>丢包和拥塞：网络中的数据丢失或拥塞可能导致RTT增加。</li></ol></li></ul></li><li><p>超时重传时间</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.25.32.png" alt="截屏2024-06-17 13.25.32.png"></p><ol><li>设置初始超时时间：通常根据网络状况和数据包大小设置一个合理的初始值。</li><li>超时等待：发送方等待预定的超时时间。</li><li>检查接收确认：如果在这段时间内接收到接收方的确认，说明数据包已经成功抵达，无需重传。</li><li>超时后重传：如果没有收到确认，计时器超时后，数据包会再次被发送。</li><li>重传次数限制：为了避免无限次的无效重传，网络协议通常设定重传的最大次数，超过这个次数还未收到确认，发送方会放弃这次传输，并可能采取其他错误处理措施。</li></ol></li><li><p>TCP流量控制—滑动窗口</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.35.20.png" alt="截屏2024-06-17 13.35.20.png"></p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.40.18.png" alt="截屏2024-06-17 13.40.18.png"></p><ol><li><p><strong>滑动窗口的工作原理</strong>：滑动窗口是一个接收方维护的、可以动态调整的接收缓冲区大小的抽象窗口。窗口的大小表示接收方可以同时接收的数据量，而不是一次性的数据块。发送方根据接收方窗口的大小发送数据，接收方接收到数据后会向发送方回送确认信息，同时更新窗口大小。发几个回一次大小的具体数值由窗口决定</p><p> <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.36.40.png" alt="截屏2024-06-17 13.36.40.png"></p></li><li><p><strong>发送方操作</strong>：当发送方收到接收方的确认（ACK）时，它可以在已发送但未收到确认的数据之外继续发送更多数据，只要这些数据不会超出接收方的当前滑动窗口。如果窗口减少，发送方就会暂停或减慢发送速度。</p></li><li><p><strong>接收方操作</strong>：当接收方无法处理更多数据时，它会通过ACK消息告知发送方将窗口大小减小，或者直接丢弃过期的数据包。这样发送方就会相应地调整发送速率，直到窗口增大。</p></li><li><p><strong>流量控制和拥塞控制</strong>：滑动窗口也涉及拥塞控制，因为当网络拥塞时，接收方可能会设置一个更小的窗口来防止更多的数据积压。发送方会感知到这种变化，并降低发送速率，直到网络状况改善。</p><p> <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.42.01.png" alt="截屏2024-06-17 13.42.01.png"></p></li><li><p>通过ACK的数值说明接收方收到包的具体数值：如ack&#x3D;40，则则之前的都发完了，下一次从数值后的包开始发送</p></li><li><p>如图蓝框中显示的窗口大小共有20，一次可以发送20个包过来，发送过程中，不用发ACK，发完后，回ACK。</p><p> <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.47.30.png" alt="截屏2024-06-17 13.47.30.png"></p><p> <img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20e5f18fd72277412abf916feb6a05e855/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.50.01.png" alt="截屏2024-06-17 13.50.01.png"></p><p> <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.52.00.png" alt="截屏2024-06-17 13.52.00.png"></p><p> <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.52.44.png" alt="截屏2024-06-17 13.52.44.png"></p></li></ol></li><li><p>粘包问题</p><p>  UDP是基于段文报传输的，就不会粘包，TCP是基于字节传输的，如同流水，数据就会粘在一起</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E6%2588%25AA%25E5%25B1%258F2024-06-17_13.57.48.png" alt="截屏2024-06-17 13.57.48.png"></p><ol><li>设置标记位：在包的开始结束设置特定标记；标记为可能与实际数据混淆，错误的分割，可能与开始和结束标志位重复(场景：游戏中发送技能)</li></ol><ul><li><p>设置标记位</p><p>  <strong>优点：</strong></p><ol><li><strong>明确边界</strong>: 设置标记位可以在数据序列中明确地指出数据段的开始和结束，帮助接收端正确识别完整的数据包。</li><li><strong>错误检测</strong>: 标记位通常与数据一起发送，当接收端发现标记位与数据不匹配时，可以判断可能存在粘包并重新请求丢失的部分。</li><li><strong>简化协议</strong>: 对于简单协议，设置固定长度的标记位可以减少协议的复杂性，提高实现的可读性和维护性。</li></ol><p>  <strong>缺点：</strong></p><ol><li><strong>额外开销</strong>: 每个数据包都需要一个额外的标记位，增加了网络传输的开销，尤其是在大数据量传输时。</li><li><strong>潜在冲突</strong>: 如果多个数据包同时到达，标记位可能会与实际数据混淆，需要精确的时间同步和处理策略。</li><li><strong>编码复杂性</strong>: 对于自定义协议或者已有协议的扩展，实现和解析带有标记位的数据可能增加编码和解析的复杂性。</li></ol></li></ul><ol><li>固定包大小： 按照固定包大小传输；容易浪费空间和资源，包的大小取决于数据最大的那个（场景：传输文件）</li></ol><ul><li><p>固定包大小</p><p>  <strong>优点：</strong></p><ol><li><strong>易于解析和处理</strong>：固定包大小使得接收端能够预先知道每个数据块的边界，从而更方便地解析和缓冲数据，避免了逐字节读取的开销。</li><li><strong>性能优化</strong>：预先设定的包大小可以帮助网络协议栈进行有效的缓存管理，减少不必要的往返次数，提升整体通信效率。</li><li><strong>稳定性</strong>：对于许多应用来说，如实时通信、流媒体等，固定的包大小有助于保证数据的即时性和一致性，减少延迟和抖动。</li></ol><p>  <strong>缺点：</strong></p><ol><li><strong>浪费带宽</strong>：如果数据量小于预设的包大小，这可能导致部分包中的数据未被完全利用，造成带宽浪费。</li><li><strong>灵活性降低</strong>：固定的包大小可能无法适应所有数据的大小变化，例如大数据块或突发流量，可能会导致包溢出或包头丢失。</li><li><strong>可能导致数据丢失</strong>：在网络条件不稳定或高延迟的情况下，如果包大小设置得过小，可能会出现部分包未成功接收，造成数据丢失。</li></ol></li></ul><ol><li>先发数据长度，再发数据包：先说明包大小，再根据包大小发送数据包；数据传输速度慢，每次发送多个包（场景：用户输入数据）</li></ol><ul><li><p>先发数据长度，再发数据包</p><p>  这样接收方可以根据这个长度来正确解析接收到的数据。发送时，数据会被分割成多个小的数据包，并在每个数据包的开始处添加长度信息；接收时，会先读取长度字段，然后根据该长度读取对应长度的数据，直到读完整个预期长度的数据。</p></li></ul><ol><li>短连接：先连接，发送包，断开连接，再对下一个包进行连接和发送：浪费时间也浪费资源（场景：比较适用浏览器）</li></ol><ul><li><p>短连接</p><p>  短连接通常指的是客户端和服务器之间的会话在发送完请求或响应后就立即关闭，不维持持久连接。<br>  例如，HTTP协议中的GET或POST请求就是典型的短连接。如果数据量较大，但协议规定一次只能发送一部分数据（如HTTP头部后跟一个空行），那么服务器发送的数据可能会超出一次接收缓冲区的容量，导致客户端接收到的数据不是完整的报文。这时，客户端需要额外处理，通过判断剩余数据是否在下一次接收中继续，或者根据特定的分隔标识（比如换行符）重新组合数据，这就是粘包处理。</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> n1;<span class="comment">//包的数据不固定，将数据整合成包发送</span></span><br><span class="line"><span class="type">int</span> nSize = <span class="built_in">sizeof</span>(n1);</span><br><span class="line"><span class="comment">//发送</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">send</span>(sockClient,(<span class="type">char</span>*)&amp;nSize,<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="number">0</span>);<span class="comment">//先发包大小</span></span><br><span class="line"><span class="built_in">send</span>(sockClient,(<span class="type">char</span>*)&amp;n1,<span class="built_in">sizeof</span>(n1),<span class="number">0</span>);<span class="comment">//先发数据包</span></span><br><span class="line"><span class="comment">//接收int nPackSize = 0;</span></span><br><span class="line"><span class="built_in">recv</span>(sockClient,(<span class="type">char</span>*)&amp;nPackSize,<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="number">0</span>);<span class="comment">//先接收包大小</span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[nPackSize];</span><br><span class="line"><span class="built_in">recv</span>(sockClient,buf,nPackSize,<span class="number">0</span>);<span class="comment">//再接收包</span></span><br><span class="line"><span class="keyword">delete</span>[]buf;</span><br></pre></td></tr></table></figure></li><li><p>心跳机制 &#x2F; TCP保活机制</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_160602.png" alt="屏幕截图 2024-06-17 160602.png"></p><p>  客户端和服务端判断双方是否在线（场景：微信），例如防火墙会把一段时间没上线的链接断开，自己实现的心跳包（好处：灵活自主方便）使用SO_KEEYPLALIVE套接字（别人做好的，但是不自主，依照别人设定好的流程写）</p><p>  参考：<br>  <a href="https://blog.csdn.net/ComplexMaze/article/details/124201088">TCP保活机制（KeepAlive）_tcp keepalive-CSDN博客</a></p><p>  如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li>如果对端程序是<strong>正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>如果<strong>对端主机崩溃</strong>，或<strong>对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 <strong>TCP 连接已经死亡。</strong></li></ul><p>  所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p><ul><li><p>TCP保活相关参数如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SO_KEEPALIVE：是否开启保活</span><br><span class="line"></span><br><span class="line">TCP_KEEPIDLE：Start keeplives after <span class="keyword">this</span> period</span><br><span class="line"></span><br><span class="line">TCP_KEEPINTVL：Interval between keepalives</span><br><span class="line"></span><br><span class="line">TCP_KEEPCNT：Number of keepalives before death</span><br></pre></td></tr></table></figure></li><li><p>保活机制示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;minwindef.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;netinet/tcp.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2ipdef.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT     (2333)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DATA (100) <span class="comment">/*接收道德数据最大程度*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DEF_VERSION_HIBYTE (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DEF_VERSION_LOBYTE (2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*加载库*/</span></span><br><span class="line"></span><br><span class="line">    DWORD version = <span class="built_in">MAKEWORD</span>(_DEF_VERSION_HIBYTE, _DEF_VERSION_LOBYTE);</span><br><span class="line">    WSAData data = &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> err = <span class="built_in">WSAStartup</span>(version, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != err) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;WSAStartup fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HIBYTE</span>(data.wVersion) != _DEF_VERSION_HIBYTE</span><br><span class="line">        || <span class="built_in">LOBYTE</span>(data.wVersion) != _DEF_VERSION_LOBYTE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;WSAStartup version fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;WSAStartup version success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    SOCKET sockfd, new_fd; <span class="comment">/*sockert句柄和建立连接后的句柄*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> my_addr</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;; <span class="comment">/*本方地址信息结构体，下面有具体的属性赋值*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> their_addr</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;; <span class="comment">/*对方地址信息*/</span></span><br><span class="line">    <span class="type">int</span> sin_size;</span><br><span class="line">    <span class="type">char</span> buf[MAX_DATA];<span class="comment">//储存接收数据</span></span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">// 建立socket</span></span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;socket failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_addr.sin_family = PF_INET; <span class="comment">/*该属性表示接收本机或其他机器传输*/</span></span><br><span class="line">    my_addr.sin_port = <span class="built_in">htons</span>(PORT); <span class="comment">/*端口*/</span></span><br><span class="line">    my_addr.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">/*IP，本机IP*/</span></span><br><span class="line">    <span class="built_in">memset</span>(my_addr.sin_zero, <span class="number">0</span>, <span class="built_in">sizeof</span>(my_addr.sin_zero)); <span class="comment">/*置0*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (sockaddr*)&amp;my_addr, <span class="built_in">sizeof</span>(sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 绑定地址结构体和socket</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">listen</span>(sockfd, BACKLOG); <span class="comment">//开启监听，第二个参数是最大监听数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sin_size = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">        new_fd = <span class="built_in">accept</span>(sockfd, (sockaddr*)&amp;their_addr, &amp;sin_size);</span><br><span class="line">        <span class="comment">// 在这里阻塞知道接收到信息，参数分别是sock句柄、接收到的信息、以及大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启保活、一分钟内探测不到、断开连接</span></span><br><span class="line">        <span class="type">int</span> keep_alive = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> keep_idle = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> keep_interval = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> keep_count = <span class="number">57</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(new_fd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">char</span>*)&amp;keep_alive, <span class="built_in">sizeof</span>(keep_alive))) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Error setsockopt(SO_KEEPALIVE) failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(new_fd, IPPROTO_TCP, TCP_KEEPIDLE, (<span class="type">char</span>*)&amp;keep_idle, <span class="built_in">sizeof</span>(keep_idle))) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Error setsockopt(TCP_KEEPIDLE) failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(new_fd, IPPROTO_TCP, TCP_KEEPINTVL, (<span class="type">char</span>*)&amp;keep_interval,</span><br><span class="line">            <span class="built_in">sizeof</span>(keep_interval))) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Error setsockopt(TCP_KEEPINTVL) failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(new_fd, IPPROTO_TCP, TCP_KEEPCNT, (<span class="type">char</span>*)&amp;keep_count, <span class="built_in">sizeof</span>(keep_count))) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Error setsockopt(TCP_KEEPCNT) failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (new_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">recv</span>(new_fd, buf, MAX_DATA, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 将接收数据打入buf，参数分别是句柄、储存处、最大长度、0</span></span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;buf:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  上述保活参数（int keep_alive &#x3D; 1;int keep_idle &#x3D; 3;int keep_interval &#x3D; 1;int keep_count &#x3D; 57;）表示3秒内无交互后，每隔1秒检测一次，57次都没得到响应时会断开连接。</p></li><li><p>Nagle算法</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_213001.png" alt="屏幕截图 2024-06-17 213001.png"></p><p>  原因：数据在网络传输时，网络并不并不关心数据大小，对于路由器来说大数据统一传输与小数据包多数传输对比而言，</p><p>  作用：前者消耗资源与空间更少，所以优先采用前者的传输方式，所以需要避免小数据块的传输，而小数据块传输对于用户而言就是网卡了。</p><p>  算法规则：</p><p>  规则3实际上就是关闭Nagle算法，想怎么发就怎么发</p><p>  规则4则是允许了在使用Nagle算法的前提下发送经过确认的小数据包（说明网络情况良好，不易拥堵）</p><p>  规则5保证了在发生超时的情况下打Nagle算法迅速传输数据，避免进一步拥堵</p></li><li><p>拥塞控制</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_214302.png" alt="屏幕截图 2024-06-17 214302.png"></p><p>  拥塞控制现象：把数据类比洪水，当河流漫过堤坝，就出现了洪水，在洪水泛滥时，如果不及时的修堤坝，洪水就会冲倒更多的堤坝，与后来的河流汇集，情况就会越来越严重。</p><p>  TCP协议的四种算法</p></li></ul><p>算法通过控制窗口的大小从而控制数据传输速度</p><p><img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_214342.png" alt="屏幕截图 2024-06-17 214342.png"></p><ul><li><p>慢开始与拥塞避免</p><ul><li><p>慢点开始，逐渐增大拥塞窗口大小，并同时使用ssthresh状态变量防止拥塞窗口增长过大造成网络拥塞</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_214839.png" alt="屏幕截图 2024-06-17 214839.png"></p></li><li><p>最初使用慢开始算法，ssthresh成倍增长增长到与拥塞避免值相同后，使用拥塞避免算法线性增长，然后窗口先掉为1，再继续循环开始算法，拥塞避免算法，期间不停更新ssthresh值</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_215310.png" alt="屏幕截图 2024-06-17 215310.png"></p></li></ul></li><li><p>快重传</p><p>  当接收方收到M1，M2，M4，并未对M3进行确认，此时则认为M3丢失，然后通过给发送方发送三个连续的对M2的重复确认ACK，那么发送方立刻重传M3。</p><p>  这一段时间是要比超时重传短的，所以叫做快重传</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_215927.png" alt="屏幕截图 2024-06-17 215927.png"></p></li><li><p>快恢复</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_220736.png" alt="屏幕截图 2024-06-17 220736.png"></p><p>  首先从收到三个重复的ACK，触发快速重传机制，然后启用慢开始算法，将cwnd变为原来的一半，ssthresh &#x3D; cwnd，然后快恢复窗口cwnd变为ssthresh（慢开始）+3，然后又开始拥塞避免了。</p></li><li><p>TCP协议总结</p><p>  对比UDP非连接，高效率，低可靠性的，基于报文段的传输方式。</p><p>  为什么TCP是可靠的？</p><p>  <strong>2个机制2种数据传输逻辑2个窗口对应的解决方案</strong></p><p>  TCP可以发广播吗？</p><p>  <strong>一对一传输。理论上不能发广播</strong></p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-17_221356.png" alt="屏幕截图 2024-06-17 221356.png"></p><p>  问题与思考</p><p>  在传输层使用TCP机制：使用按顺序储存的队列，运用计时器按时返回ACK保证数据传输可靠，并且加入超时重传机制</p><p>  TCP发广播：并发多线程实现</p><p>  三次握手时能不能发送数据：能，在第三次挥手时，客户端只发送了个ACK</p><p>  四次挥手时能不能发送数据：对于主动方来说。只有第一次，对于被动方带了FIN的包都能带数据，包括发送FIN在内之前的包都能带数据</p><p>  如果四次挥手的过程中主动方发送ACK后，ACK丢失，则被动方发送FIN也同样丢失，被动方能否关闭：被动方会多次发送ACK后自动关闭（自闭）这一段时间是漫长的，会浪费时间与资源</p></li></ul><p>在使用void*强转地址时，需要正确的强转(格式要正确)，当强转失败时，会报这个错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x794CECC1</span> (Qt5Cored.dll)处(位于 xxx.exe 中)引发的异常: <span class="number">0xC0000005</span>: 读取位置 <span class="number">0x0000003F</span> 时发生访问冲突。</span><br><span class="line">处未处理的异常: <span class="number">0xC0000005</span>: 读取位置 <span class="number">0x00000000</span>时发生访问冲突</span><br></pre></td></tr></table></figure><p><img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-19_214245.png" alt="屏幕截图 2024-06-19 214245.png"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20e5f18fd72277412abf916feb6a05e855/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-19_214312.png" alt="屏幕截图 2024-06-19 214312.png"></p><p>注意区分二者区别，其他类型转换也是同样的道理</p><p><img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-20_170336.png" alt="屏幕截图 2024-06-20 170336.png"></p><p>线程函数的参数传入是this指针：对该指针进行初始化，直接使用this指向该类</p><ul><li><p>ip地址与网络地址互转</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ws2tcpip.h<span class="comment">//头文件</span></span><br><span class="line"><span class="type">char</span> ip[<span class="number">20</span>] = <span class="string">&quot;192.168.0.74&quot;</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addr_in</span> to;</span><br><span class="line">sockaddr_in _sin = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(ip);</span><br><span class="line"><span class="comment">/*inet_pton()用于将 Internet 网络地址转换为数字二进制形式*/</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, &amp;_sin.sin_addr, ip, (<span class="type">void</span>*)&amp;to);</span><br><span class="line"><span class="comment">/*inet_ntop()用于将数字二进制形式转换为 Internet 网络地址*/</span></span><br><span class="line"><span class="built_in">inet_ntop</span>(AF_INET,,ip,size);</span><br><span class="line"><span class="comment">//若无错误，inet_ntop()函数返回一个指向缓冲区的指针,</span></span><br><span class="line"><span class="comment">//该缓冲区包含标准格式的IP地址的字符串表示形式</span></span><br><span class="line"><span class="comment">//否则返回NULL</span></span><br><span class="line"><span class="comment">//获取错误码WSAGetLastError()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT WSAAPI inet_pton(</span></span><br><span class="line"><span class="comment">  [in]  INT   Family,</span></span><br><span class="line"><span class="comment">  [in]  PCSTR pszAddrString,</span></span><br><span class="line"><span class="comment">  [out] PVOID pAddrBuf</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PCSTR WSAAPI inet_ntop(</span></span><br><span class="line"><span class="comment">  [in]  INT        Family,</span></span><br><span class="line"><span class="comment">  [in]  const VOID *pAddr,</span></span><br><span class="line"><span class="comment">  [out] PSTR       pStringBuf,</span></span><br><span class="line"><span class="comment">  [in]  size_t     StringBufSize</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>TCP协议接收数据函数读取数据过大解决方案</p><p>  <img src="/../%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%BD%91%E5%9B%BE%E7%89%87/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE_2024-06-20_195725.png" alt="屏幕截图 2024-06-20 195725.png"></p><p>  由于TCP协议在读取容量过大的数据时，会拆分成多段，这时候对多个传输过来的数据而言，定义while循环，判断每个接受包内容是否大于0，从而判断是否接收完成；</p><p>  对一个包而言，则是通过已知pack始终指向包的起始位置，nRecvFrom为每次接收包的长度，从而定义变量packSize为一次往后读取的包大小，offset为偏移量，从而得出公式：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packSize -= nRecvFrom；</span><br><span class="line">offset += nRecvFrom； </span><br></pre></td></tr></table></figure><p>  含义是一个包数据拆分成多个段，recv每次读取一段，pack通过+offset的偏移每次指向该段的开头，而packSize每次随着段数的减少递减</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;p&gt;协议protocol，网络是虚拟的，分为发送端和接收端，数据在传输中需要遵守规则，这个规则即为协 议&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库系统概论</title>
    <link href="http://example.com/2024/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2024/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</id>
    <published>2024-09-27T06:56:06.000Z</published>
    <updated>2024-09-27T07:03:45.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库系统概念"><a href="#数据库系统概念" class="headerlink" title="数据库系统概念"></a>数据库系统概念</h1><h2 id="数据库基础概念"><a href="#数据库基础概念" class="headerlink" title="数据库基础概念"></a>数据库基础概念</h2><p><strong>数据库管理系统（DataBase-Management System，DMBS）</strong>由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。这个数据集合通常称作<strong>数据库（database）</strong></p><p>概括地说，有两种使用数据库的方式。</p><p>第一种方式是支持<strong>联机事务处理（online transaction processing）</strong>，即大量的用户使用数据库，每个用户检索相对少量的数据，进行小的更新。这是数据库应用系统的绝大多数用户的主要使用方式。</p><p>第二种方式是支持<strong>数据分析（data analytics）</strong>，即审阅数据，给出结论，并推导出规则或决策程序，以用于驱动业务决策。</p><p><strong>数据挖掘（data mining）</strong>领域将人工之恩那个研究者和统计分析员所创造的知识发现技术与使之能够被用于超大规模数据库的高效的实现技术结合起来。</p><p><strong>文件处理系统（file-processing system）</strong>是传统的操作系统所支持的。系统将永久记录存储在多个不同的文件中，需要有不同的应用程序来将记录从有关文件中去除或加入适当的文件中。</p><ul><li><strong>文件处理系统的主要弊端：</strong><ol><li><strong>数据的冗余和不一性（data redundancy and inconsistency）</strong><ol><li>同一份数据存在了不同的地方，如一个老师必然它的数据在教务系统存了一份，在人事系统也存了一份，这样相同的数据存在多个地方，就会<strong>存储浪费，访问麻烦</strong>。而且导致**数据不一致性()**的问题，你修改了某一个文件的信息时，不一定修改了另一个的文件的信息，那么数据就不一致。</li></ol></li><li><strong>数据访问困难（difficulty in accessing data）</strong><ol><li>需要找出满足特定范围或特定需求的数据时，缺少这样的一个列表的程序，不支持以一种方便而高效的方式去获取所需数据，需要开发通用的、反应更加敏捷的数据检索系统。</li></ol></li><li><strong>数据孤立（data isolation）</strong><ol><li>由于数据分散在不同文件中，这些文件又可能具有不同的格式，因此编写新的应用程序来检索适当数据很困难</li></ol></li><li><strong>完整性问题（integrity problem）</strong><ol><li>数据库中所存储数据的值必须满足某些特定类型的<strong>一致性约束（consisteny constraint）</strong>。在不同程序受到不同约束的数据，难以进行统一维护</li></ol></li><li><strong>原子性问题（atomicity problem）</strong><ol><li>要么全部发生，要么根本不发生。</li></ol></li><li><strong>并发访问异常（concurrent-access anomaly）</strong><ol><li>同时10个人抢一张票，那么只能允许一个人搞到票，也就是并发访问控制。而票这个数据，同时被10个客户端修改成功，那么就出问题了。</li></ol></li><li><strong>安全性问题（security problem）</strong><ol><li>并非数据库系统的每一个用户都可以访问所有数据。</li></ol></li></ol></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h3><ol><li><strong>关系模型（relational model）</strong><ol><li>关系模型用表的集合来表示数据和数据间的联系。表也称作关系。</li></ol></li><li><strong>实体-联系模型（entity-structured data model ）</strong><ol><li>实体-联系（E-R）数据模型使用称作实体的基本对象的集合，以及这些对象间的联系</li></ol></li><li><strong>半结构化模型（semi-structured data model）</strong><ol><li>半结构化数据模型允许在其数据定义中某些相同类型的数据项含有不同的属性集。</li></ol></li><li><strong>基于对象的数据模型（object-bsed data model）</strong><ol><li>过程可以被存放在数据库系统中，并由数据库系统来执行它们，这可以看成对关系模型进行扩展，增加了封装、方法和对象标识等。</li></ol></li></ol><p><strong>数据抽象：对用户屏蔽复杂性，以简化用户与系统的交互</strong></p><ul><li><strong>物理层（physical level）：</strong>最低层次的抽象，描述数据实际上是怎样存储的。物理层描述复杂的底层数据结构</li><li><strong>逻辑层（logical level）：比物理层次稍高的抽象，描述数据库中存储什么数据以及这些数据库间存在什么联系。虽然逻辑层的简单结构的实现可能设计复杂的物理层结构，但逻辑层的用户不必意识到这样的复杂性，</strong></li><li><strong>视图层（view level）：最高层次的抽象，它只描述整个数据的某些部分。视图层抽象的存在正是为了使这些用户与系统的交互更简，系统为同一数据库提供多个视图。</strong></li></ul><h3 id="实例和模型"><a href="#实例和模型" class="headerlink" title="实例和模型"></a><strong>实例和模型</strong></h3><p>特定时刻存储在数据库中的信息的集合称作数据库的一个<strong>实例（instance），</strong>而数据库的总体设计称作数据库<strong>模式（schema）。</strong></p><p>按不同的抽象层次划分，数据库系统有几种模式。<strong>物理模式（physical schema）</strong>在物理层描述数据库的设计 ，而<strong>逻辑模式（logical schema）</strong>则在逻辑层描述数据库的设计。数据库在视图层也可以有几种模式，有时称为<strong>子模式（subschema）</strong>，它描述了数据库的不同视图。</p><h3 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a><strong>数据库语言</strong></h3><p>数据库系统提供<strong>数据定义语言（Data-Definition Language，DDL）</strong>来定义数据库模式，并提供<strong>数据操作语言（Data-Manipulation Language，DML）</strong>来表达数据库的查询和更新。</p><p><strong>数据定义语言</strong></p><p>数据库模式是通过一系列定义来说明的，这些定义由一种称作<strong>数据定义语言</strong>的特定语言来表达。DDL也可用于定义数据的其他特征。</p><p>通过一系列特定的DDL语句来说明数据库系统所采用的存储结构和访问方式，这种特定的DDL称作数据存储和定义（data storage and definition）语言。这些语句定义了数据库模式的实现细节。</p><p>存储在数据库中的数据值必须满足某些<strong>一致性约束</strong>：</p><ul><li><strong>域约束（domain constraint）：</strong>每个属性都必须对应于一个所有肯恶搞的取值构成的域（如，整数型、字符型、日期&#x2F;时间型）</li><li><strong>引用完整性（referential integrity）：</strong>希望能确保一个关系中给定属性集上的取值也在零一关系的某一属性集的取值中出现。</li><li><strong>授权（authorization）</strong>：对于不同的用户在数据库中的不同数据值上允许不同的访问类型。这些区别以<strong>授权</strong>来表达。常见的是：<strong>读权限（read authorization）</strong>，允许读取数据，但不能修改数据；<strong>插入权限（insert authorization），</strong>允许插入新数据，但不允许修改已有数据；更新权限<strong>（update authorization）</strong>，允许删除数据。我们可以赋予用户所有或部分这些权限，也可以不赋予用户任何这些权限。</li></ul><p>DDL的输出放在<strong>数据字典（data dictionary）</strong>中，数据字典包含元数据（metadata），元数据是关于数据的数据。</p><p><strong>数据操纵语言</strong>是这样一种语言，它使得用户可以访问或操纵那些按照某种适当的数据模型组织起来的数据。有以下访问类型：</p><ul><li>对存储在数据库中的信息进行检索</li><li>向数据库中插入新的信息</li><li>修改数据库中存储的信息</li></ul><p>基本上由两种类型的数据操纵语言：</p><ul><li><strong>过程化的DML（procedural DML）</strong>要求用户指定需要什么数据以及如何获得这些数据</li><li><strong>声明式的DML（declarative DML）（也称为非过程的DML）</strong>只要求用户指定需要什么数据，而不必指明如何获得这些数据。</li></ul><p><strong>查询（query）</strong>是要求对信息进行检索的语句。DML中涉及信息检索的部分称作<strong>查询语言（query language）</strong></p><h3 id="从应用程序访问数据库"><a href="#从应用程序访问数据库" class="headerlink" title="从应用程序访问数据库"></a>从应用程序访问数据库</h3><p><strong>应用程序（application program）</strong>就是用来以这种方式与数据库进行交互的程序。</p><p>为了访问数据库，需要将DML语句从宿主发送到执行这些语句的数据库。最通用的办法是使用应用程序接口（过程集合），它可以用来将DML和DDL的语句发送给数据库，再取回结果。开放数据库连接（ODBC）标准定义用于C语言和其他几种语言的应用程序接口，Java数据库连接（JDBC）标准为Java语言提供了相应的接口。</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>概念设计（conceptual-design）</strong>设计者选择一个数据模型，并运用该选定的数据模型的概念，将那些需求转换成一个数据库的概念模式。</p><p><strong>规范化（normalization）</strong>它将所有属性集作为输入，生成一组关系表。</p><p>在<strong>功能需求说明（specification of functional requirement）</strong>中，用户秒火速将在数据之上执行的各种操作（或事务）。</p><p>在<strong>逻辑设计阶段（logical-desgin phrase）</strong>，设计人员将高层的概念模式映射到要使用过的实现数据库系统的数据模型上。……设计人员将得到的特定于系统的数据库模式用到后续的<strong>物理设计阶段（physical-design phrase）</strong>中，在这个阶段说明数据库的物理特性，这些特性包括文件组织的形式以及内部的存储结构。</p><h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p>数据系用的功能部件大致可分为存储管理器、<strong>查询处理器（query processor）</strong>部件和事物管理部件。</p><p>一个<strong>GB（gigabyte）</strong>大约为10亿字节，或1024个<strong>MB（megabyte）兆</strong>字节，而一个<strong>TB（terabyte）</strong>大约为1万亿字节，或<strong>1024个MB</strong>。最大的企业的数据库规模达到数个<strong>PB（petabyte）</strong>千万亿字节，或<strong>1024个TB。</strong></p><p><strong>存储管理器（storage manager）</strong>是数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。原始数据通过操作系统提供的文件系统存储在<strong>磁盘</strong>上。存储管理器将各种DML语句翻译为底层文件系统命令。因此，存储管理器负责数据库中数据的<strong>存储、检索和更新</strong></p><p><strong>存储管理器部件</strong>包括</p><ul><li><strong>权限及完整性管理器（authorization and integrity manager）</strong>，它检测是否满足完整性约束，并检查试图访问数据的用户的权限。</li><li><strong>事物管理器（transaction manager）</strong>它保证即使系统发生故障，数据库也保持在一致的状态，并保证并发事务的执行不发生冲突。</li><li><strong>文件管理器（file manager），</strong>它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</li><li><strong>缓冲区管理器（buffer manager）</strong>，它负责将数据从磁盘上取到内存中，并决定哪些数据应被缓冲存储在内存中。</li><li><strong>数据文件（data file）</strong>它存储数据库自身。</li><li><strong>数据字典（data fictionary）</strong>它存储关于数据库结构的元数据，特别数据库模式。</li><li><strong>索引（index）</strong>它提供对数据项的快速访问。提供了指向包含特定值的数据项的指针。</li></ul><p><strong>查询处理器</strong></p><p>查询处理器组件包括：</p><ul><li><strong>DDL解释器（DDL interpreter）</strong>它解释DDL语句并将这些定义记录在数据字典中</li><li><strong>DML解释器（DML interpreter）</strong>它将查询语言中的DML语句翻译为包括一些列查询执行引擎能理解的低级指令的执行方案。DML编译器还进行<strong>查询优化（query optimization）</strong>，就是从几个候选执行计划中选出代价最小的那个。</li><li><strong>查询执行引擎（query evaluation engine）</strong>它执行由DML编译器产生的低级指令。</li></ul><h3 id="事物管理"><a href="#事物管理" class="headerlink" title="事物管理"></a><strong>事物管理</strong></h3><p>这种要么都发生要么都不发生的要求称作<strong>原子性。</strong>除此以外，资金转账的执行还必须保持数据库的一直行。例如：A和B的余额之和应该是保持不变的。这种正确性要求称作<strong>一致性</strong>。最后，当资金转账成功结束后，即使发生系统故障，账户A和B的余额也应该保持转账成功结束的新值。这种保持的要求称作<strong>持久性</strong>。</p><p><strong>事物（transaction）</strong>是数据库应用中完成单一逻辑功能的操作集合。每一个事物是一个既具有原子性又具有一致性的单元。</p><p>原子性和持久性的保证是数据库系统自身的职责，确切的说，是<strong>恢复管理器（recovery manager）</strong>的职责。</p><p><strong>故障恢复（failure recovery）</strong>：即它必须检测系统故障并将数据恢复到故障发生以前的状态。</p><p><strong>并发控制管理器（concurrency-control manager）</strong>控制并发事物间的相互影响，保证数据库的一致性。<strong>事物管理器（transaction manager）</strong>包括并发控制管理和恢复管理器。</p><h3 id="数据库和应用体系结构"><a href="#数据库和应用体系结构" class="headerlink" title="数据库和应用体系结构"></a>数据库和应用体系结构</h3><p>较早一代的数据库应用系统采用两层体系结构（two-tier architeture），其中应用程序驻留在客户机上，通过查询语言来调用服务器上的数据库系统功能。</p><p>而当今的数据库应用系统采用三层体系结构</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库系统概念&quot;&gt;&lt;a href=&quot;#数据库系统概念&quot; class=&quot;headerlink&quot; title=&quot;数据库系统概念&quot;&gt;&lt;/a&gt;数据库系统概念&lt;/h1&gt;&lt;h2 id=&quot;数据库基础概念&quot;&gt;&lt;a href=&quot;#数据库基础概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="http://example.com/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2024-09-26T22:11:58.000Z</published>
    <updated>2024-09-27T07:15:20.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1. 概论"></a>1. 概论</h1><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/0101.jpg" alt="0101.jpg"></p><h2 id="（1）计算机系统概论"><a href="#（1）计算机系统概论" class="headerlink" title="（1）计算机系统概论"></a>（1）计算机系统概论</h2><p>计算机系统由“硬件”和“软件”组成，</p><p>硬件指的是计算机的实体部分，如主机、外部设备等软件通常分为两大类：系统软件和应用软件。</p><p>系统软件又称为系统程序，主要用来管理整个计算机系统。包括标准程序库、语言处理程序（如将汇编语言翻译成机器语言的汇编程序和将高级语言译成机器语言的编译程序）、操作系统（如批处理系统、分时系统、实时系统）、服务程序（如诊断程序、调试程序、连接程序等）、数据库管理系统、网络系统等。</p><p>应用软件又称为应用程序，它是用户根据需要所编制的各种程序、如科学计算程序、数据处理程序、过程控制程序、事务管理程序等。 </p><p>计算机解题过程通常由用户用高级语言编写程序（称为源程序），然后它和数据一起送入计算机，再由计算机将其翻译成机器能识别的机器语言程序（称为目标程序），机器自动运行该机器语言程序，并输出计算结果。</p><p>实际上，早期的计算机只有机器语言（用0、1代表示的语言），用户必须用二进制代码来编写程序（即机器语言程序）</p><p>上世纪50年代出现了符号式的程序设计语言，即<strong>汇编语言</strong>。它用符号ADD、SUB、MUL、DIV等分别表示加减乘除，并用符号表示指令或数据所在存储单元的地址。但实际上，没有一种机器能够直接识别这种汇编语言程序，必须先将汇编语言程序翻译成机器语言程序，然后才能被机器接受并自动运行。</p><p>上世纪60年代出现了各种面向问题的<strong>高级语言</strong>，如FORTRAN、BASIC、Pascal、C等。机器必须先将高级语言程序翻译成汇编语言程序。然后将其翻译成机器语言程序；也可以将高级语言程序直接翻译成机器语言程序。</p><p>通常，将高级语言程序翻译成机器语言成的软件称为翻译程序。翻译程序由两种：一种是编译程序，另一种是解释程序。<strong>编译程序</strong>是将用户编写的高级语言程序（源程序）的全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序。如FORTRAN、Pascel等语言。<strong>解释程序</strong>是将源程序的一条语句翻译成对应于机器语言的一条语句，并且立即执行这条语句，接着翻译源程序的下一句，并执行这条语句，如此重复直至完成源程序的全部翻译任务。如BASIC语言的翻译就有解释程序和编译程序两种。</p><p><strong>计算机体系结构</strong>是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。计算机系统的属性通常是指用机器语言编程的程序员（也包括汇编语言程序设计者和汇编程序设计者）所看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术、I&#x2F;O机理等，大都属于抽象的属性。</p><p><strong>计算机组成</strong>是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。如组成计算机系统的各个功能部件的结构和功能，及相互连接方法，如指令系统体现了机器的属性，这是属于<strong>计算机结构</strong>的问题。</p><p>但指令的实现，即如何取细节、分析指令、取操作数、运算、送结果等这些都属于<strong>计算机组成</strong>问题。</p><p>冯诺依曼机的特点：</p><ul><li>计算机由运算器、存储器、控制器、输入设备和输出设备两大组成。</li><li>指令和数据以同等地位存放于存储器内，并可按地址寻访</li><li>指令和数据均用二进制数表示</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质、地址码用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结构或根据设定的条件改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ul><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/424f8cc2b46d7c8b311591477b7d54d.jpg" alt="424f8cc2b46d7c8b311591477b7d54d.jpg"></p><ul><li>运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内。</li><li>存储器用来存放数据和程序</li><li>控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果</li><li>输入设备用来将人们的熟悉的信息形式转换为机器能识别的信息形式，常见的由键盘、鼠标等</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。</li></ul><p>通常把<strong>运算器</strong>和<strong>结构器</strong>合起来统称为<strong>中央处理器（Central Processing Unit，CPU）</strong>。把输入设备与输出设备简称为 I&#x2F;O 设备（Input&#x2F;Output Equipment）。</p><p>现代计算机可认为由三大部分组成：<strong>CPU、I&#x2F;O设备</strong>及<strong>主存储器（Main Memory，MM）</strong>，如图1.9所示。CPU与主存储器合起来又称为主机，I&#x2F;O设备又可称为外部设备。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/49b5503a8566006e01218d39f675da2.jpg" alt="49b5503a8566006e01218d39f675da2.jpg"></p><p><strong>主存储器</strong>是存储器子系统中的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类称为辅助存储器。简称辅存，又称外存。</p><p><strong>主机</strong>是计算机硬件的主体部分，由CPU和主存储器MM合成为主机。<br><strong>主存</strong>计算机中存放正在运行的程序和数据的存储器，为计算机的主要工作存储器，可随机存取;由存储体、各种逻辑部件及控制电路组成。<br><strong>存储单元</strong>可存放一个机器字并具有特定存储地址的存储单位。<br><strong>存储元件</strong>存储一位二进制信息的物理元件，是存储器中最小的存储单位，又叫存储基元或存储元，不能单独存取。<br><strong>机器字长</strong>指CPU一次能处理的二进制数据的位数，通常与CPU的寄存器位数有关。 </p><p><strong>指令字长</strong>:一条指令的二进制代码位数。<br><strong>存储字长</strong>一个存储单元所存二进制代码的位数。一般与机器字长相等（准64位机与准32位机例外。例如准64位机机器字长64位、存储字长32位）<br>**存储容量:**存储器中可存二进制代码的总量;(通常主、辅存容量分开描述)。</p><p><strong>存储容量 &#x3D; 存储单元个数（由地址总线的数量决定） x  存储字长（和数据总线的数量一致）</strong><br><strong>存储基元</strong>是计算机内部存储的最小信息单位，也称为<strong>存储元件</strong>或<strong>存储元素</strong>。它代表了计算机存储系统中的最小数据单位，可以存储二进制数字0或1。每个存储基元都有一个唯一的地址，可以通过这个地址访问和读取其中的数据。<strong>存储元</strong>是计算机存储体系中的基本组成单位，用于存储二进制数据。存储元可以是电阻、电容、晶体管、集成电路等基本元件，也可以是专门设计的存储器件，<br><strong>存储字</strong>是指计算机存储体系中的最小数据单位，也称为<strong>存储元</strong>或<strong>存储元素</strong>。它代表了计算机存储系统中的最小数据单位，可以存储二进制数字0或1。<br><strong>指令字长</strong>是指机器指令中包含的二进制代码的总位数，也称为有效字长。它取决于从操作码的长度、操作数地址的长度和操作数地址的个数。在不同的计算机系统中，指令字长可能不同。</p><p><strong>算术逻辑单元（Arithmetic Logic Unit，ALU</strong>简称算逻部件，用来完成算术逻辑运算。</p><p><strong>控制单元（Control Unit，CU</strong>用来解释存储器中的指令，并发出各种操作命令来执行指令。ALU和CU是CPU的核心部件。I&#x2F;O设备也受CU控制，用来完成相应的输入、输出操作。</p><p><strong>程序计数器（PC，Program counter</strong>，用于存放指令的地址。</p><p><strong>指令寄存器（IR，Instruction Register</strong>，用来保存当前正在执行的一条指令。</p><p><strong>通用寄存器（GR，General register</strong>通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。</p><p><strong>累加器（ACC，Accumulator）</strong> 是运算器中既能存放运算前的操作数，又能存放运算结果的寄存器。</p><p><strong>乘商寄存器（MQ，Multiplier-Quotient Register）</strong>，乘法运算时存放乘数、除法时存放商的寄存器。</p><p><strong>X:此字母没有专指的缩写含义</strong>可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来存放操作数;<br><strong>存储器地址寄存器（MAR:Memory Address Register）</strong>，在主存中用来存放欲访问的存储单元的地址。</p><p><strong>存储器数据缓冲寄存器（MDR:Memory Data Register）</strong>，在主存中用来存放从某单元读出、或要写入某存储单元的数据。</p><p><strong>每秒执行百万条指令数（MIPS:Million Instruction Per Second）</strong>，为计算机运算速度指标的一种计量单位。</p><p><strong>CPI（Clock cycle Per Instrucion）</strong>：执行一条指令所需的时钟周期数<br><strong>执行一条指令的耗时 &#x3D; CPI x CPU时钟周期</strong></p><p><strong>CPU执行时间&#x3D; CPU时钟周期数&#x2F;主频&#x3D; （指令条数*CPI）&#x2F;主频</strong></p><p>**IPS（Instructions Per Second）[KIPS、MIPS]**：每秒执行多少条指令</p><p>**FLOPS（Floatin-point Operations Per Second）[KFLOPS、MFLOPS、GFLOPS、TFLOPS]**：每秒执行多少次浮点运算</p><p>K&#x3D;Kilo&#x3D;千&#x3D;10的3次方，M&#x3D;Million&#x3D;百万&#x3D;10的4次方，G&#x3D;Glga&#x3D;十亿&#x3D;10的九次方，T&#x3D;Tera&#x3D;万亿&#x3D;10的12次方</p><p><strong>计算机区分存储器中的指令和数据主要有两种方法：</strong></p><p>方式一：通过不同时间段来区分指令和数据，即在取指令阶段（或取值微指令）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。</p><p>方式二：通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。</p><p>存储器中的每段存储空间都会有一个地址，每个指令都包括一段操作数和一段空间地址，cpu会根据操作数去处理地址所指的数据。一般计算机先读取存储器最开始的内容（这一部分是指令），然后加载操作系统后由操作系统对硬盘文件系统结构（即是数据）以判断其他数据和指令的位置。<br><strong>什么是指令？什么是数据？</strong></p><p>指令：指令是指计算机执行某种操作的命令，它由一串二进制数码组成。计算机执行了一指令序列，便可完成预定的任务，这一指令序列就称为程序；<br>程序：一系列指令的有序集合称为程序<br>指令的执行过程分为四步：1.取指令；2.分析指令；3.执行指令；4.完成上述操作后，指令计数器加1，为执行下一条指令做准备。</p><h3 id="1-3计算机的工作步骤"><a href="#1-3计算机的工作步骤" class="headerlink" title="1.3计算机的工作步骤"></a><strong>1.3计算机的工作步骤</strong></h3><p><strong>1、建立数学模型</strong></p><p><strong>2、确定计算方法</strong></p><p><strong>3、编制解题程序：将运算步骤用一一对应的机器指令描述</strong></p><p><strong>（1）预备知识</strong></p><ul><li>操作码（6位：表示机器所执行的各种操作，如取数、存数、加、减、乘、除、停机、打印等。</li><li>地址码（10位：表示参加运算的数在存储器内的位置。机器指令的操作码和地址码都采用0、1代码的组合来表示。</li><li>指令格式举例：</li></ul><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image.png" alt="image.png"></p><ul><li><p>操作码举例：<br>000001 取数（将指令地址指示的存储单元中的操作数取到运算器的累加器ACC中）、000010 存数（将ACC中的数存至地址码知识的存储单元中）、000011 加（将ACC中的数与指令地址码指示的存储单元的数相加，结果存于ACC中）、000100 乘（将ACC中的数与指令地址码指示的存储单元的数相乘，结果存于ACC中）、000101 打印（将指令地址码指示的存储单元的数打印输出）、000110 停机</p><p>  <strong>（2）计算机组成框架</strong></p><p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%201.png" alt="image.png"></p></li><li><p>主存储器（简称主存&#x2F;内存<br>-包含若干存储单元，每个存储单元包含若干存储元件，每个存储元件可以寄存一位二进制代码“0”“1”等。<br>-配置两个寄存器MAR和MDR。<br>-MAR为存储器地址寄存器，用来存放欲访问的存储单元的地址，位数对应存储单元的个数。<br>-MDR是存储器数据寄存器，用来存放从存储体某单元取出的代码或者准备往某存储单元存入的代码，七位数与存储字长相等。</p></li></ul><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%202.png" alt="image.png"></p><ul><li><p>运算器</p><p>  至少包括三个寄存器+一个算术逻辑单元ALU</p><p>  三个寄存器：ACC 累加器、MQ 乘商寄存器、X操作数寄存器</p><p>  各个寄存器所存放的各类操作数</p><p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%203.png" alt="image.png"></p></li></ul><p>（M为存储器的任一地址号、[M]为地址号中的内容）</p><p>加法操作过程：</p><p>1.[M]-&gt;X 先从主存中取加数[M]，送至运算器的X寄存器中</p><ol start="2"><li>[ACC]+[X]-&gt;ACC 将ACC中的被加数与加数结果存入累加器中</li></ol><p>控制器</p><ul><li>由程序控制器&#x2F;PC （顺序执行）、指令寄存器&#x2F;IR（操作码、地址码）、控制单元&#x2F;CU（对操作码中的指令进行译码分析）组成，用来解释指令&#x2F;保证指令的按序执行</li><li>单目操作符不需要访问内存</li></ul><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%204.png" alt="image.png"></p><p><strong>1.9 画出主机框图，分别以存数指令“STA M”和加法指令“ADD M”（M均为主存地址）为例，在图中按序标出完成该指令（包括取指阶段）的信息流程。假设主存容量为256M*32位，在指令字长、存储字长、机器字长相等的条件下，指出图中各寄存器的位数。</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%205.png" alt="image.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%206.png" alt="image.png"></p><h2 id="（2）计算机的发展史及应用"><a href="#（2）计算机的发展史及应用" class="headerlink" title="（2）计算机的发展史及应用"></a>（2）计算机的发展史及应用</h2><p>1.第一代电子管计算机<br>第一代电子管计算机——ENIAC(The Electronic Numerical Integrator And Computer)，1946年在费城公诸于世，它通过不同部分之间的重新接线编程，还拥有并行计算能力，但功能受限制，速度也慢。ENIAC的问世标志现代计算机的诞生，是计算机发展史上的里程碑<br>2.第二代晶体管计算机<br>第二代晶体管计算机 晶体管的发明大大促进计算机的发展，晶体管代替电子管，电子设备体积减小。1956年，晶体管在计算机中使用，晶体管和磁芯存储器导致了第二代计算机的产生。第二代计算机体积小、速度快、功耗低、性能更稳定。首先使用晶体管技术的是早期的超级计算机，主要用于原子科学的大量数据处理，这些机器价格昂贵，生产数量极少。<br>3.第三代集成电路计算机<br>第三代集成电路计算机 晶体管比起电子管进步，但产生的大量热量损害计算机内部的敏感部分。1958年发明了集成电路(IC)，将电子元件结合到一片小小的硅片上，使更多的元件集成到单一的半导体芯片上。于是，计算机变得更小，功耗更低，速度更快。这一时期的发展还包括使用了操作系统，使计算机在中心程序的控制协调下可以同时运行许多不同的程序。1964年，美国IBM公司研制成功第一个采用集成电路的通用电子计算机系列IBM360系统。<br>4.第四代大规模集成电路计算机<br>第四代大规模集成电路计算机 大规模集成电路(LSI)可以在一个芯片上容纳几百个元件。到了80年代，超大规模集成电路(VLSI)在芯片上容纳了几十万个元件，后来的ULSI将数字扩充到百万级。可以在硬币大小的芯片上容纳如此数量的元件使得计算机的体积和价格不断下降，而功能和可靠性不断增强。基于“半导体”的发展，到了一九七二年，第一部真正的个人计算机诞生了。<br>5.第五代智能计算机<br>第五代智能计算机 1981年，在日本东京召开了第五代计算机研讨会，随后制订出研制第五代计算机的长期计划。智能计算机主要特征是具备人工智能，能像人一样思考，并且运算速度极快，其硬件系统支持高度并行和推理，其软件系统能够处理知识信息。神经网络计算机（也称神经元计算机）是智能计算机的重要代表。但第五代计算机目前仍处在探索、研制阶段。真正实现后,将有无量的发展前途,它的前景,必将是光辉诱人的。<br>6.第六代生物计算机<br>第六代生物计算机 半导体硅晶片的电路密集，散热问题难以彻底解决，影响了计算机性能的进一步突破。研究发现，DNA的双螺旋结构能容纳巨量信息，其存储量相当于半导体芯片的数百万倍。一个蛋白质分子就是存储体，而且阻抗低、能耗小、发热量极低。基于此，利用蛋白质分子制造出基因芯片研制生物计算机，已成为当今计算机技术的最前沿。生物计算机比硅晶片计算机在速度、性能上有质的飞跃，被视为极具发展潜力的“第六代计算机”。</p><hr><p>2.3计算机的展望<br>分子计算机：分子计算机的运算速度是目前计算机的1000亿倍，最终将会取代硅芯片计算机。</p><p>量子计算机：量子力学证明，个体光子通常不相互作用，但是当它们与光学谐腔内的原子聚在一起时，它们相互之间会产生强烈的影响。光子的这种特性可用来发展量子力学效应的信息处理器件—光学量子逻辑门，进而制造出量子计算机。</p><p>DNA计算机： 科学家研究发现，脱氧核糖核酸有一种特性，能够携带生物体的大量基因物质。数学家、生物学家、化学家以及计算机专家从中获得启迪，正在合作研制未来的液晶DNA电脑。</p><p>神经元计算机：将来，人们制造能够完成类似人脑功能的计算机系统，即人造神经元网络。神经元计算机最有前途的应用是国防：它可以识别物体和目标，处理复杂的雷达信号，决定要击毁的目标。神经元计算机的联想式信息存储、对学习的自然适应性、数据处理等性能都异常有效。</p><p>生物计算机：生物计算机主要是以生物电子元件构建的计算机。它利用蛋白质的开关特性，用蛋白质分子作为元件从而制成的生物芯片。其性能是由元件与元件之间的电流启闭开关速度来决定的。由蛋白质构成的集成电路，其运行速度非常快，大大超过了人脑的思维速度。</p><ol><li>通常计算机的更新换代以什么为依据？<br>答： 主要以组成计算机基本电路的元器件为依据，如电子管、晶体管、集成电路等。</li><li>举例说明专用计算机和通用计算机的区别。<br>答：按照计算机的效率、速度、价格和运行的经济性和实用性可以将计算机划分为通用计算机和专用计算机。通用计算机适应性强，但牺牲了效率、速度和经济性，而专用计算机是最有效、最经济和最快的计算机，但适应性很差。例如个人电脑和计算器。</li><li>什么是摩尔定律？该定律是否永远生效？为什么？<br>摩尔定律是由英特尔创始人之一戈登·摩尔提出来的。其内容为：积体电路上可容纳的电晶体（晶体管）数目，约每隔两年便会增加一倍；经常被引用的“18个月”，是由英特尔首席执行官大卫·豪斯所说：预计18个月会将芯片的性能提高一倍（即更多的晶体管使其更快）。<br>该定律不会一直生效。原因有：其一，硅芯片的集成度要受其物理极限的制约，集成度不可能永无止境的提高；其二由于芯片集成度提高时，其制作成本也在不断提高；其三，随着集成度的提高，微处理器内部的功耗、散热、线延迟等一系列的问题将难以解决。</li></ol><h1 id="2-计算机系统的硬件结构"><a href="#2-计算机系统的硬件结构" class="headerlink" title="2. 计算机系统的硬件结构"></a>2. 计算机系统的硬件结构</h1><h2 id="（3）系统总线"><a href="#（3）系统总线" class="headerlink" title="（3）系统总线"></a>（3）系统总线</h2><p>计算机系统的五大部件之间的互连方式有两种，一种是各部件之间使用单独的连线，称为分散连接；另一种是将各部件连到一组公共信息传输线上，称为总线连接。</p><p>随着I&#x2F;O设备的种类和数量越来越多，分散连接不利于人们随时增添或减撤设备，硬件复杂度上升，由此出现了总线连接。</p><p><strong>总线是连接多个部件的信息传输线，是各部件共享的传输介质</strong>。当多个部件与总线相连时，如果出现两个或两个以上部件同时向总线发送信息，势必导致信号冲突，传输无效。因此，在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。</p><p>总线实际上是由许多传输线或通路组成，每条线可一位一位地传输二进制代码，一串二进制代码可在一段时间内逐一传输完成。若干条传输线可以同时传输若干位二进制代码，例如，16条传输线组成的总线可同时传输16位二进制代码。</p><p><strong>最简单的输入接口是三态门，最简单的输出接口是锁存器寄存器。</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/01623ba16705d741b6ff1cd3db5301d.jpg" alt="01623ba16705d741b6ff1cd3db5301d.jpg"></p><p>它是在单总线基础上又开辟出的一条CPU与主存之间的总线，称为存储总线。这跟总线速度高，只供主存与CPU之间传输信息。这样既提高了传输效率，又减轻了系统总线的负担，还保留了I&#x2F;O设备与存储器交换信息时不经过CPU的特点。现代计算机大多数采用各类总线结构。</p><p><strong>总线分类</strong></p><p>按数据传送方式可分为并行传输总线和穿行传输总线，在并行传输总线中，又可按传输数据宽度分为8位，16位，32位，64位等传输总线。若按总线的使用范围划分，则又有计算机（包括外设）总线、测控总线。</p><p><strong>片内总线</strong></p><p>片内总线是指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间，寄存器与算逻单元ALU之间都由片内总线连接。</p><h3 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a><strong>系统总线</strong></h3><p>系统总线是指CPU、主存、I&#x2F;O设备（通过I&#x2F;O接口）各大部件之间的信息传输线。由于这些部件通常都安放在主板或各个插件版上（插卡）上，故又称版级总线（在一块电路板上个芯片间的连线）或版间总线。</p><p>按系统总线传输信息的不同，又可分为三类：数据总线、地址总线和控制总线。</p><p>1、数据总线(DB)双向用来传输各功能部件之间的数据信息，它是<strong>双向</strong>传输总线，其位数与机器字长、存储字长有关（不一定一致，有例外）。</p><p>2、地址总线(AB)用来指出数据总线上的源数据或目的数据所在的主存单元或 I&#x2F;O 端口的地址，它是<strong>单向</strong>传输总线，地址总线的位数与主存地址空间的大小有关。决定存储单元个数</p><p>3、 控制总线(CB)传输的是控制信息,包括 CPU 送出的控制命令和主存(或外设)返回 CPT的反馈信号。存储器读写、总线允许、中断确认。有输入有输出。</p><ul><li><p><strong>常见的控制信号：</strong></p><p>  时钟：用来同步各种操作</p><p>  复位：用来初始化所有部件</p><p>  总线请求：表示某部件需获得总线使用权</p><p>  总线允许：表示需要获得总线使用权的部件已获得了控制权</p><p>  中断请求：表示某部件提出中断请求</p><p>  中断响应：表示中断请求已被接受</p><p>  存储器写：将数据总线上的数据写至存储器的指定地址单元内</p><p>  I&#x2F;O读：从指定的I&#x2F;O端口将数据读到数据总线上</p><p>  I&#x2F;O写：将数据总线上的数据输出到指定的I&#x2F;O端口内</p><p>  传输响应：表示数据已被接收，或已将数据送至数据总线上</p></li></ul><h3 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h3><p>这类总线用于<strong>计算机系统之间</strong>或<strong>计算机系统与其他系统</strong>（如控制仪表，移动通信等）之间的通信。按传输方式可分为两种：串行通信和并行通信</p><p>串行通信（不同设备）是指数据在单条1位宽的传输线上，一位一位地按顺序分时传送。</p><p>并行通信是指数据在多条并行1位宽的传输线上，同时由源传送到目的地。</p><p>采用串行通信费用远比并行通信费用低得多，此外串行通信还可利用现有的电话网络来实现远程通信，降低通信费用，但是在数据发送和接收的时候，要进行拆卸和装配，要考虑串行、并行转换的问题。 </p><aside>❓ （1）总线宽度是一次总线操作中，最多可传递的数据位数。<p>（2）总线周期是一次总线操作所需要的最小间隔时间。总线周期与总线的时钟频率成反比，即T&#x3D;1&#x2F;f。</p><p>3）总线宽度是单位时间内通过总线的数据位数，总线的数据传输率，单位为MB&#x2F;s。<br>(4) 标准传输率即在总线上每秒能传输的最大字节量，用 MB&#x2F;s 表示。例如，总线工作频率为33MHz，总线宽度为 32 位，则它最大的传输率为 132 MB&#x2F;s。<br>(5) 总线复用。通常地址总线与数据总线在物理上是分开的两种总线，地址总线传输地址码，数据总线传输数据信息。为了提高总线的利用率，可优化设计，让地址总线和数据总线共用一组物理线路，这称为总线的多路复用。<br>除了上述主要性能指标外，还有其他指标。例如，负载能力问题，由于不同的电路对总线的负载是不同的，即使同一电路板在不同的工作频率下，总线的负载也是不同的，因此，总线负载能力的指标不是太严格，通常用可连接扩充电路板数来反映总线的负载能力</p><p> 总带宽 &#x3D; 存储器总线频率 × 存储器总线位宽 × 存储器通道数 ÷ 8 </p></aside><h3 id="单总线结构："><a href="#单总线结构：" class="headerlink" title="单总线结构："></a><strong>单总线结构：</strong></h3><p>单总线结构将 CPU、主存及 I&#x2F;O 设备(通过 I&#x2F;O接口)都挂在一组总线上，支持I&#x2F;O设备与主存、I&#x2F;O 设备之间直接交换信息。</p><p>其结构简单，便于扩充，但因各部件共享一组总线，极易造成计算机系统的瓶颈现象。当I&#x2F;O 设备量很大时，总线发出的控制信号从一端逐个传送到第n个设备，它的传播延迟也会造成计算机系统工作效率的严重下降。</p><p><strong>为解决总线瓶颈问题，可采取增加总线宽度和提高传输速率等方法。</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled.png" alt="Untitled"></p><h3 id="双线结构："><a href="#双线结构：" class="headerlink" title="双线结构："></a><strong>双线结构：</strong></h3><p>单总线结构的缺陷是系统效率和连接到总线上的各设备的利用率不高。这是因为单总线不允许多于两台的设备在同一时刻交换信息。为了克服这一缺陷，可将 I&#x2F;O 总线与主存总线分开，形成了双总线结构。</p><p>这种总线结构有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送，另一条是I&#x2F;O 总线用于多个外围设备与通道之间进行数据传送，如图所示。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%201.png" alt="Untitled"></p><h3 id="三总线结构："><a href="#三总线结构：" class="headerlink" title="三总线结构："></a><strong>三总线结构：</strong></h3><p>三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这条总线分别是主存总线、I&#x2F;O总线和直接主存存取(Direct Memory Access，DMA)总线。</p><p>主存总线用于 CPU 和主存之间传送地址、数据和控制信息。I&#x2F;O 总线用于 CPU 和各类外围设备之间通信。DMA 总线用于主存和高速外围设备之间直接传送数据。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%202.png" alt="Untitled"></p><h3 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h3><ol><li><strong>机械特性</strong></li></ol><p>指总线的物理连接方式，包括总线的根数，总线的插头、插座的形状,引脚线的排列方式等。</p><ol><li><strong>功能特性：</strong></li></ol><p>描述总线中每根传输线的功能。例如，地址总线用来给存储器、IO 口编号，以便 CPU 按地址对其进行读写;数据总线是 CPU 和存储器、外设之间传送指令和数据的通道，其宽度反映了 CPU 一次处理和传送的二进制位数;</p><ol><li><strong>电气特性 :</strong></li></ol><p>定义每一根线上信号的传递方向及有效电平范围。其中，送入 CPU 的信号称为输入信号(IN)，从 CPU 发出的信号称为输出信号OUT)。</p><ol><li><strong>时间特性:</strong></li></ol><p>定义了每根线在什么时间有效。规定了总线上各信号有效的时序关系 CPU才能正确无误的使用。</p><aside>❓ **CPU总线：**是计算机系统中最快的总线。这条总线主要由CPU使用，用来与高速缓存、主存和北桥之间传送信息。CPU总线是一个64位数据线和32位地址线的同步总线，时钟频率为66 MHz，100 MHz，133 MHz等。CPU是这条总线的主控者，但必要时可放弃总线控制权。**PCI总线：**用于连接高速的I/O设备模块，如显卡、网卡、硬盘控制器等。PCI总线通过北桥与CPU总线连接，通过南桥与ISA总线相接。PCI总线是一个同步总线，32位（或64位）数据/地址线是同一组线，分时复用。**ISA总线：**用于连接低速的I/O设备模块。主板上一般留有3～4个ISA总线扩充槽，以便使用各种16位/8位适配器卡。</aside><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%203.png" alt="Untitled"></p><h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%204.png" alt="Untitled"></p><p>总线带宽指总线的最大数据传输率，即总线在进行数据传输时，单位时间内最多可传输的数据位数，通常用Mb&#x2F;s (Mbps)或MB&#x2F;s(MBps)表示。</p><p>总线的数据传输率可表示为:数据传输率&#x3D;总线宽度数据传输次数&#x2F;秒，数据传输次数&#x2F;秒又称为工作频率。注意，总线带宽的工作频率不考虑总线仲裁、地址传送等非数据传输操作的时间，而总线数据传输率的工作频率考虑总线所有操作的时间。<br>对于同步总线，总线带宽 B&#x3D;wXf&#x2F;m，其中，w 为总线宽度，f为总线时钟频率，m为一次数据传输所需的时钟周期数，f&#x2F;m 表示总线的工作频率。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%205.png" alt="Untitled"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%206.png" alt="Untitled"></p><h3 id="总线接口的基本概念"><a href="#总线接口的基本概念" class="headerlink" title="总线接口的基本概念"></a><strong>总线接口的基本概念</strong></h3><p>连接到总线上的设备都需要有一个接口电路，而不能直接把它的内部线路连接到总线上。总线上有一套信号线的定义，又有一套通信规则（又称协议），连接到总线上的信号都要符合总线的这些要求，总线还是各部件之间的连接界面，由于各部件之间存在各种差异，所以需要总线接口来弥补这些差异。</p><p>接口即I&#x2F;O设备适配器，具体指CPU和主存、外围设备之间通过总线进行连接的逻辑部件。接口在它连接的两个部件之间起着“转换器”的作用，以便实现彼此之间的信息传送。为了使所有的外围设备能够兼容，并能在一起正确地工作，CPU规定了不同的信息传送控制方法。一个标准接口可能连接一个设备，也可能连接多个设备。CPU、接口和外围设备之间的连接关系如图所示。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%207.png" alt="image.png"></p><p><strong>一个适配器必有两个接口</strong></p><p><strong>一是和系统总线的接口</strong>，<strong>CPU和适配器的数据交换一定的是并行方式；</strong></p><p><strong>二是和外设的接口</strong>，<strong>适配器和外设的数据交换可能是并行方式，也可能是串行方式。</strong></p><p><strong>根据外围设备数据传送方式的不同，适配器可分为串行数据接口和并行数据接口两大类。</strong></p><h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a><strong>总线控制</strong></h3><p>主要包括判优控制（或称仲裁逻辑）和通信控制</p><p>总线判优控制</p><p>总线上所连接的各类设备，按其对总线有无控制功能可分为主设备（模块）和从设备（模块）两种。只有获得总线使用权的主设备才能开始传送数据。</p><p>总线判优控制可分集中式和分布式两种，前者将控制逻辑集中在一处（如在CPU中），后者将控制逻辑分散在与总线连接的各个部件或设备上。</p><p><strong>（1）链式查询</strong></p><p>总线同意信号（BG）是<strong>串行</strong>地从一个I&#x2F;O接口送到下一个I&#x2F;O接口，如到达的接口无总线请求，则继续往下传；如到达的接口有总线请求，则不再往下传，这意味着该I&#x2F;O接口获得了<strong>总线使用权</strong>。<strong>BG信号就像一条链一样串联所有的设备接口，故这种总线控制方式称为链式查询方式。</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%208.png" alt="image.png"></p><p>在这种电路中，除一般数据总线D和地址总线A外，在控制总线中有三根线用于总线的控制，分别是<strong>总线忙（BS）线、总线请求（BR）线和总线同意（BG）线。</strong> </p><aside>💡 **BS：**总线忙/闲状态线，当其有效时，表示总线正被某外设使用。<p><strong>BR：</strong>总线请求线。当其有效时，表示至少有一个外围设备正在请求使用总线。</p><p><strong>BG：</strong>总线同意线。当其有效时，表示总线控制部件已响应总线请求（BR）。</p></aside><p><strong>（2）计时器定时查询</strong></p><p>工作原理是，总线上任一设备要求使用总线时，通过总线请求（BR）线发出总线请求信号，总线控制器接到请求信号后，在总线忙（BS）为复位的情况下，让计数器开始计数，计数值通过一组地址线发至各设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址一致时，该设备把总线忙（BS）置位，获得总线控制权。此时，中止计数器的计数及查询。</p><p>没有链式敏感：当某个设备的接口中有关键的电路出现故障时，不会影响期待设备使用总线</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%209.png" alt="image.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2010.png" alt="image.png"></p><p><strong>（3）独立请求方式</strong></p><p>这种总线控制方式中，每一个共享总线的设备均有一对<strong>总线请求（BR）和总线同意（BG）线</strong>。当设备要求使用总线时，便发出总线请求信号，总线控制部件中有一个排队电路，根据一定的优先次序决定首先响应哪个设备的请求，当请求的设备排上队，便收到总线同意（BG）信号，从而可以使用总线。</p><p>优点：对优先次序的控制也相当地灵活，它可以预先固定优先次序，也可以通过程序来改变优先次序，并且在必要时屏蔽某些设备的请求。</p><p>缺点：控制器复杂</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2011.png" alt="image.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2012.png" alt="image.png"></p><p><strong>2、分布式判优控制</strong></p><p>分布式控制不需要中央仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当某一个或多个功能块有总线请求时，把它们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号大，则它的总线请求不予响应，并撤销它的仲裁号。</p><p>最后，获胜者的仲裁号保留在仲裁总线上。</p><p><strong>仲裁比较</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2013.png" alt="image.png"></p><h3 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a><strong>总线通信</strong></h3><p>总线的一次信息传送过程，大致可分为如下几个阶段：<strong>请求总线，总线仲裁，寻址，信息传送，状态返回。</strong></p><p>请求总线：由需要使用总线的主设备提出请求。</p><p>总线仲裁：总线仲裁机构决定将下一传输周期的总线使用授权于某一主设备。</p><p>寻址： 取得了使用权的主设备通过总线发出本次要访问的从设备的地址及有关命令，启动参与本次传输的从设备。</p><p>信息传送： 主设备和从设备进行数据交换，数据由源设备发出，经数据总线流入目的设备。</p><p>状态返回： 主设备的有关信息均从总线上撤除，让出总线使用权。</p><p><strong>1、同步通信：</strong><br>总线上的设备（或部件）通过总线进行信息传送时，用一个公共的时钟信号进行同步，这种方式称为同步通信。这个公共的时钟信号可以由总线控制部件发送到每一个设备（或部件），也可以每个设备（或部件）有自己的时钟发生器，但是都必须由CPU发出的时钟信号进行同步。由于采用统一的时钟，每个设备（或部件）发送信息或接收信息都在固定的总线传送周期中，一个总线传送周期结束，开始下一个总线传送周期。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2014.png" alt="image.png"></p><p>如上图表示某个输入设备向CPU传输数据的同步通信过程。总线传输周期是连接在总线上的两个部件完成一次完整且可靠的信息传输时间，它包含4个时钟周期T1，T2，T3和T4。同步通信在系统总线设计时，对T1，T2，T3，T4都有明确且唯一的规定：T1主设备发地址；T2主设备发读命令；T3从设备提供数据；T4主设备撤销读命令，从设备撤销数据。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2015.png" alt="image.png"></p><p>对于写命令，其传输周期为：<strong>T1主设备发地址；T1主设备提供数据；T2主设备发出写命令</strong>，从设备接收到命令后，必须在规定时间内将数据总线上的数据写到地址总线所指明的单元中；<strong>T4主设备撤销写命令和数据</strong>。写命令传输周期的时序如图所示。</p><aside>💡<p>同步通信的优缺点：</p><p>优点是具有较高的传输速率，数据传输速度快，总线控制逻辑也比较简单。同步通信适用于总线长度较短，各部件存取时间比较接近的情况。<br>缺点是控制线的数量多，例如，要控制n个设备，必须有n根总线请求线和n根总线同意线，相比之下，链式查询方式只需1根总线请求线和1根总线同意线。另外，独立请求方式的控制器也要复杂得多。</p></aside><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2016.png" alt="image.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2017.png" alt="image.png"></p><p><strong>2、异步通信：</strong><br>利用数据发送设备和数据接收设备之间的相互“握手”信号来实现总线数据传送的方式称为异步通信。在异步通信中，没有统一的时钟，也没有固定的时间问题，完全依靠传送双方相互制约的“握手”信号来实现定时控制，把交换信息的两个设备（或部件）分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p><aside>💡 **异步通信的优缺点：**<ol><li>优点是总线周期长度可变，能保证两个工作速度相差很大的设备（或部件）之间可靠地进行信息交换，自动适应时间的配合。</li><li>缺点是比同步通信复杂，速度也较慢。</aside></li></ol><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2018.png" alt="image.png"></p><p><strong>（1）不互锁方式。</strong><br>主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系，如图所示。</p><p><strong>（2）半互锁方式。</strong><br>主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图所示。</p><p><strong>（3）全互锁方式。</strong><br>① 主设备发出“请求”信号，等待从设备的“应答”信号； ② 从设备接到“请求”信号后，发出“应答”信号——一次握手； ③ 主设备接到从设备的“应答”信号，就撤销其“请求”信号——二次握手； ④ 从设备在获知主设备已撤销“请求”信号后，随即撤销其应答信号——三次握手。 这样，经过三次握手在通信双方建立了完全的互锁关系，如图所示。</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2019.png" alt="image.png"></p><p><strong>3、半同步通信：</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2020.png" alt="image.png"></p><p><strong>4、分离式通信：</strong></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2021.png" alt="image.png"></p><p><strong>5、总线数据传送模式</strong><br>当代的总线标准大都能支持以下4类模式的数据传送。</p><p>（1）读、写操作。<br>读操作是由从方到主方的数据传送；写操作是由主方到从方的数据传送。一般，主方先以一个总线周期发出命令和从方地址，经过一定的延时再开始数据传送总线周期。为了提高总线利用率，减少延时损失，主方完成寻址总线周期后可让出总线控制权，以使其他主方完成更紧迫的操作。然后再重新竞争总线，完成数据传送总线周期。</p><p>（2）块传送操作。<br>只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入。对于CPU（主方）、存储器（从方）而言的块传送，常称为猝发式传送，其块长一般固定为数据线宽度（存储器字长）的4倍。</p><p>（3）写后读、读后写操作。<br>只给出地址一次，或进行先写后读操作，或进行先读后写操作。前者用于校验目的，后者用于多道程序系统中对共享存储资源的保护。这两种操作和猝发式操作一样，主方掌管总线直到整个操作完成。</p><p>（4）广播、广集操作。<br>一般而言，数据传送只在一个主方和一个从方之间进行。但有的总线允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集，它将选定的多个从方数据在总线上完成AND或OR操作，用以检测多个中断源。</p><p><strong>六、常见问题和易混淆知识点</strong><br>同一个总线是否能既采用同步通信又采用异步通信 半同步通信总线可以。</p><p>这类总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。</p><p>一个总线在某一时刻是否可以有多对主从设备进行通信 不可以。</p><p>在某一总线周期内，总线上只有一个主设备控制总线。</p><p><strong>七、本章总结</strong><br>1、总线是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通道，并在争用资源的基础上进行工作。</p><p>2、总线有物理特性、功能特性、电气特性、机械特性，因此必须标准化。衡量总线性能的重要指标是总线带宽，它的定义为总线本身所能达到的最高传输速率。</p><p>3、计算机系统中，根据应用条件和硬件资源不同，信息的传输方式可采用串行传送，并行传送和分时传送。</p><p>4、总线仲裁是总线系统的核心问题之一。为了解决多个主设备同时竞争总线控制权的问题，必须具有总线仲裁部件。</p><p>5、总线通信是总线系统的又一核心问题之一。为了同步主方、从方的操作，必须制订通信协议，通常采用同步通信与异步通信两种方式。</p><p>6、目前，典型的总线标准有ISA，EISA，VESA，PCI，PCI-Express，AGP，RS-232C，USB等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送</p><h2 id="（4）存储器"><a href="#（4）存储器" class="headerlink" title="（4）存储器"></a>（4）存储器</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/3a7493da074bcbbe63b510666f063ad6.png" alt="3a7493da074bcbbe63b510666f063ad6.png"></p><p><strong>按存储介质分类：</strong></p><ol><li><p>半导体存储器：</p><p> 由半导体器件组成的存储器，当电源消失时，所存储信息随之消失，为一种<strong>易失性</strong>存储器，其优点是<strong>体积小、功耗低、存取时间短</strong>。用非挥发性材料制成的半导体存储器克服了信息易失的弊病。</p><p> 按照材料的不同：</p><ul><li>双极型（TTL）半导体存储器：工作速度快，与CPU处在同一量级，但是集成度低、功耗大、价格偏高</li><li>MOS半导体存储器：高集成度，制造简单，价格低廉，功耗小，但是速度较双极型器件慢</li></ul></li><li><p>磁表面存储器</p><p> 在金属或塑料基体的表面涂上一层磁性材料作为记录介质，工作时磁层随载体高速运转，磁头在磁层上进行读写操作，按照剩磁状态的不同而区分”0”和”1”，具有非易失的特点</p><p> 磁表面存储器分类（按照载磁体形状不同）：</p><ul><li>磁盘</li><li>磁带</li><li>磁鼓（已经基本不使用了）</li></ul></li><li><p>磁芯存储器</p><p> 由硬磁材料做出的环状元件，在磁芯中穿有驱动线（通电流）和读出线，这样就可以进行读&#x2F;写操作，磁芯为磁性材料，所以也是一种非易失的永久记忆存储器</p><p> 由于体积过大，工艺复杂，功耗大，于是已经基本不使用了</p></li><li><p>光盘存储器</p><p> 应用激光在记录介质（磁光材料）上进行读&#x2F;写的存储器，具有非易失性的特点。</p></li></ol><p><strong>按存取方式分类：</strong></p><p><strong>随机存取存储器（RAM，Random Access Memory）</strong></p><p>也被称为随机存储器或者读写存储器，存取时间和存储单元的物理地址无关，为一种可读&#x2F;写存储器，在存储器的任何一个存储单元的内容都可以随机存取，存取的时间和存储单元的物理位置无关（计算机的主存都采用这种随机存储器。一般的RAM芯片，关闭电源以后所存信息将全部丢失，故RAM常用来暂存运行的程序和数据。高速缓冲存储器Cache就是使用高速的静态RAM组成的小容量存储器<br><strong>随机存储器分类（按照存储原理的不同）</strong></p><ul><li>静态RAM：以触发器原理寄存信息</li><li>动态RAM：以电容充放点原理寄存信息</li></ul><p><strong>只读存储器（ROM，Read Only Memory）</strong></p><p>早期的ROM因为技术不成熟所以无法擦写，出厂后就只能读数据，所以叫只读存储器，即一但存储了原始信息以后，在程序执行的过程中，只能将内部信息读出，无法随意改变原始信息。掉电以后所存信息不会丢失，故ROM通常将其用来存放固定不变的程序、常数、汉字字库，甚至用来进行操作系统的固化，ROM的内容是由生产厂家或者用户使用专用设备写入固化的。存数据的时间和存储单元的物理位置无关。只读存储器和随机存储器可共同作为主存的一部分，统一构成主存的地址域</p><p>硬盘和ROM的关系<br>由于ROM和硬盘都可以存储数据而且断电不会丢失，而且都广泛运用于电子产品中，所以很容易对两者产生混淆，这里进行一个大概的区分：硬盘分为两种，一种是机械硬盘（即磁盘HDD）,一种是固态硬盘（SSD），机械硬盘和ROM没什么关系，但是固态硬盘用到的存储颗粒基于NAND FLASH闪存技术，该技术ROM技术发展的产物，所以说硬盘和ROM还是多多少少有些关系的，但不能说ROM就是硬盘<br><strong>只读存储器分类（根据用户需求不同而制造的不同只读存储器）</strong></p><ul><li>掩模型只读存储器（MROM）</li><li>可编程只读存储器（PROM）</li><li>可擦除可编程只读存储器（EPROM）</li><li>用电可擦除可编程只读存储器（EEPROM）</li></ul><p><strong>串行访问存储器</strong></p><p>对存储单元进行读&#x2F;写操作时，需要按照存储单元的物理位置的先后顺序寻找地址，根据信息所在物理位置的不同，存取时间会有所差异，即存取的时间和存储单元的物理地址相关</p><p><strong>串行访问存储器分类（根据访问数据的方式不同）</strong></p><ul><li>顺序存取存储器：无论信息处在哪里，读&#x2F;写必须从其介质的始端开始顺序访问，比如，磁带存储器的读&#x2F;写过程</li><li>直接存取存储器：整个读&#x2F;写过程的前段为直接访问，后段为顺序访问，比如对磁盘进行读&#x2F;写时，首先直接指出该存储器中的某一个区域（即磁道），然后再开始进行顺序访问</li></ul><p><strong>按在计算机中的作用不同：</strong></p><p>存储器主要分为主存储器、辅助存储器、缓冲存储器。</p><p>一个熟悉的缓冲存储器就是高速缓冲存储器Cache（一般使用静态RAM构成），速度高于主存</p><p><strong>缓存Cache和缓冲区buffer的区别</strong></p><p>1、缓冲区属于内存空间，是内存空间的一部分。我们在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据（就像人落地的时候，需要进行一个缓冲一样，数据的传递也需要一个缓冲），然后我们把这部分预留的空间就叫做缓冲区</p><p><strong>buffer的全称其实为buffer cache，偏重于写，一般被称为写缓存write cache</strong></p><aside>❓ 在没有加入缓冲区概念的时候，应用程序都是直接将内存中的数据传递给硬盘空间，但是由于内存相对于硬盘来说，速度极快，这样整体数据传递的速率就会因为硬盘速率低而过慢，导致内存中的应用程序效率过低<p>在加入缓冲区的概念后，应用程序可以先将数据交给同在内存中的缓冲区，然后就可以执行其他任务（由于同在内存中，所以这个数据传递过程是极快的），在缓冲区中将要写入硬盘的数据暂存下来后再将缓冲区中的数据传递给硬盘空间，等缓冲区的数据取完后再次进行缓冲区的数据填充，这样就可以减少磁盘的读写次数，所以应用缓冲区可大大提高计算机的运行速度（比如原来是每秒要写100次硬盘，对系统冲击很大，此时用缓冲区将数据暂存起来，就会变成每10秒写一次硬盘，对系统的冲击就很小，写入效率也高了）</p></aside><p>2、CPU中的Cache的中文名称是高速缓冲存储器。根据程序的局部性原理，当计算机执行程序时，数据与地址管理部件会预测可能要用到的数据和指令，并将这些数据和指令预先从内存中读出送到Cache。一旦需要时，先检查Cache，若有就从Cache中读取，若无再访问内存。Cache就是用来解决CPU与内存之间速度不匹配的问题，避免内存与辅助内存频繁存取数据，这样就提高了系统的执行效率<br><strong>cache偏重于读，一般被称为读缓存read cache</strong></p><p><strong>主存可以和CPU直接交换信息</strong>；</p><p><strong>闪速存储器（Flash Memory）</strong></p><p>为半导体存储器，速度高于磁盘，低于主存，可以在主存和辅存之间实现二者速度的弥补，起缓冲作用，U盘就是使用闪速存储器制作的，闪速存储器可以在一些高性能计算机中作为硬盘</p><p>实际上，闪速存储器是在只读存储器EPROM和EEPROM的工艺基础上产生的一种新型，可靠性更高的可擦非易失性存储器，具有整片擦除的特点，对于需要周期性修改存储信息的应用场合，闪速存储器为一个极其理想的器件，因为其至少可以擦除&#x2F;编程10000次</p><p>辅存是主存的后援存储器，用来存放当前暂时不用的程序和数据，<strong>它不能与CPU直接交换信息</strong>，两者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。</p><p>缓存用来两个速度不同的部件之中。</p><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a><strong>存储器的层次结构</strong></h3><p>存储器具有三个性能指标：速度，容量，每位价格。一般来说速度越高，位价越高；容量越大，位价越低；容量越大，速度必然越低</p><p>由存储器的性能指标之间的关系，可见人们追求的大容量、高速度、低位价的存储器是很难实现的，于是我们提出了存储器的层次结构，来尽可能解决这个矛盾</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%207.png" alt="Untitled"></p><p>该图中，由上至下，存储器价位越来越低，速度越来越慢，容量越来越大，CPU访问的频度也越来越少</p><ul><li>最上层的寄存器通常制作在CPU芯片内部，存储的数据直接在CPU内部参与运算，这里，可能要补充一些知识：寄存器不仅仅存在于CPU内部，I&#x2F;O端口中也会有寄存器存在。对于有些寄存器，指令对于这些寄存器是可以直接操作的，而且这些寄存器对于机器语言程序员来说并不是透明的，称为体系结构寄存器</li><li>中间的主存用来存放将要参与运行的程序和数据，速度与CPU相差较大（而且是剪刀差），为了进行速度匹配，添加了一个高速缓存Cache，现代计算机将Cache也制作在CPU内部</li><li>下层的磁盘、磁带属于辅助存储器，容量比内存大得多，用来存放暂时未被使用的程序和数据，CPU不能直接访问辅存，辅存只能和主存交换信息，因此辅存的速度可以比主存慢得多</li></ul><h3 id="存储器的存储层次"><a href="#存储器的存储层次" class="headerlink" title="存储器的存储层次"></a><strong>存储器的存储层次</strong></h3><p>存储体系：指使用两种或者两种以上的存储介质，用软件、硬件、或者是软硬件相结合的方式将它们链接成一个统一的整体，使得从某一级程序员的角度出发，这个整体（即表明对于程序员来说这个整体是透明的）具有高速度、大容量、低价格的特点</p><p>缓存-主存这一层次的速度接近于缓存，而容量和价位却接近于主存<br>主存-辅存这一层次的速度接近于主存，而容量和价位却接近于辅存<br>于是可以发现，这样的缓存、主存、辅存三级结构（由两个存储体系构成）解决了前面提到的矛盾，现代计算机系统几乎都具有这两个存储层次</p><p><strong>1、缓存-主存</strong></p><p>主要解决CPU和主存速度不匹配的问题，于是采用硬件的方法把缓冲主存链接为一个存储体系</p><p>解决方式：由于缓存的速度比主存高，于是只要将CPU近期要调用的信息存入缓存（使用了程序的局部性原理），CPU即可直接从速度较快的缓存中获取信息，提高了访存速度。但是同时由于缓存的容量较小，于是需要不断地将主存的数据存入缓存中，使缓存原来的数据被替换掉，这个过程是硬件自动完成的，对程序员来说是透明的</p><p><strong>2、主存-辅存</strong></p><p>主要解决存储系统容量的问题，于是采用软硬件相结合的方法把主存辅存链接为一个存储体系</p><p>解决方式：辅存的容量比主存大得多，当CPU需要辅存中的数据时，再将辅存的信息存入主存，供CPU直接访问，主存和辅存之间的信息调动是由硬件和操作系统共同完成的</p><p><strong>虚拟存储系统（Virtual Memory，VM）</strong></p><p>虚拟存储器是为了满足用户对存储空间不断增长的需求而提出的一种计算机存储器管理技术，它是建立在主存-辅存这一物理层次结构基础之上，由辅助硬件及操作系统存储管理软件组成的一种存储体系。在这个存储系统中，程序员编写的程序的地址范围与虚拟存储器的地址空间相对应，即程序员编程的时候，可用的地址空间是远远大于主存空间的</p><p>虚地址</p><p>虚拟存储器的存储单元个数远远大于主存的实际存储单元个数，所以用户编程使用的不是实际地址，而是比实际地址位数更长的地址，这种地址是面向程序需要，而不需要考虑所编程序将来在主存中的实际地址，我们一般称这些虚拟存储器的存储单元对应的地址码为虚地址（虚存地址、虚拟地址、逻辑地址），虚地址从0开始。CPU可以访问的虚地址空间，甚至可以达到整个辅存容量</p><p>实地址<br>我们把主存各个存储单元实际存在的地址称为实地址（物理地址），物理地址才是程序在执行过程中真正能够访问的地址</p><p>虚实地址的转化</p><p>虚地址转变为实地址的工作是由计算机系统的硬件和操作系统自动完成的，对程序员是透明的。当虚地址的内容就在主存中时，则通过地址变换机制，将虚地址转换为实地址，然后访问主存的实际单元；当虚地址的内容不在主存中时，则要先将虚地址的内容传递到主存中的合适单元后，再让机器使</p><p>对虚拟存储器的直观描述（可能并不那么正确）</p><p>当物理内存（就是你的内存条）不够的时候，在硬盘上借用一块空间当内存来用，但是由于这块空间不是物理内存提供的，所以会将这部分硬盘空间称为”虚拟内存”（Windows系统的虚拟内存大小可以进行人为设置，Linux系统中的SWAP（交换分区）也是一个虚拟内存）<br>由于虚拟内存实际是硬盘中的空间，所以其相同空间的价格要比物理内存低廉，而容量也是以GB为初始单位<br>执行的程序只会向操作系统申请空间，不会考虑物理内存是否足够大<br>由于硬盘传输的速度要比内存传输速度慢的多，所以虚拟内存比物理内存的效率要慢得多<br>断电后数据丢失。和物理内存一样，在电脑遇到突然断电后，虚拟内存中的数据就会丢失，不像我们平时的硬盘（外部存储器）断电还有保存功能</p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a><strong>主存储器</strong></h3><p><strong>主存储器内部组成的细化</strong></p><p>实际上，根据MAR中的地址访问某一个存储单元时，存储器内部还需要经过地址译码、驱动等电路的运行，才能找到所需访问的存储单元。将地址线接入译码器，从译码器输出端接出的线称为选择线，用于选定译码器指定的存储单元</p><p>读出数据时，存储器内部还必须经过读出放大器，才能将被选中的存储单元中的存储字送到MDR中；写入时，必须经过写入电路，才能将数据写入被选中的存储单元中</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%208.png" alt="Untitled"></p><h3 id="主存储器与CPU的联系"><a href="#主存储器与CPU的联系" class="headerlink" title="主存储器与CPU的联系"></a><strong>主存储器与CPU的联系</strong></h3><ul><li>物理上的联系<ul><li>现代计算机的主存都由半导体集成电路构成，驱动器，译码器以及读写电路均制作在存储芯片中，而MAR和MDR则制作在了CPU中（在后续介绍CPU内部结构的时候，就会体现这一点），存储芯片和CPU芯片使用系统总线相连接</li></ul></li><li>功能上的联系<ul><li>当要从主存储器中读出某一信息字时，首先由CPU将该字的存储地址发送给MAR，通过地址总线，主存接收到地址，CPU发送读命令，主存将该存储单元的信息字读出，放在数据总线上，读操作完成<br>  当要向主存储器存入某一信息字时，首先由CPU将该字的存储地址发送给MAR，通过地址总线，主存接收到地址，CPU发送写命令，主存将数据总线上的信息字写入对应的存储单元中，写操作完成</li></ul></li></ul><h3 id="主存储器中存储单元地址编号的分配方式"><a href="#主存储器中存储单元地址编号的分配方式" class="headerlink" title="主存储器中存储单元地址编号的分配方式"></a><strong>主存储器中存储单元地址编号的分配方式</strong></h3><p>不同的机器，存储字长也不同，为了满足字符处理的需要，常用8位二进制表示一个字节，同时存储字长都设定为8的倍数。计算机系统既可以按照字（即存储字长）进行寻址，也可以按照字节进行寻址，即可以使用字地址和字节地址两种地址实现存储器中数据的定位</p><p>下面使用大端存储和小端存储两种不同的方式存储同一个十六进制数12345678为例（注意1为最高位，8为最低位）对主存储器存储单元地址的分配方式进行进一步的展示（这里的”大端存储和小端存储”中的”大端”和”小端”即为文章——C语言存储篇中提到的”大端”和”小端”的概念）</p><ul><li><p>大端（大尾）存储方式</p><p>  将一个存储单元的高位字节地址作为该存储单元地址的数据存储方式</p><p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%209.png" alt="Untitled"></p></li><li><p>小端（小尾）存储方式</p><p>  将一个存储单元的低位字节地址作为该存储单元地址的数据存储方式</p><p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%2010.png" alt="Untitled"></p></li></ul><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a><strong>主存的技术指标</strong></h3><p><strong>存储容量</strong></p><p>指主存可以存储的二进制代码的总位数，即<strong>存储容量&#x3D;存储单元个数 * 存储字长</strong>，计算出的存储容量的单位为”位”（容量也可以使用字节总数来表示，即<strong>存储单元个数*存储字长&#x2F;8</strong>，计算出的存储容量的单位为MB，GB，TB等单位）</p><p><strong>存储速度</strong></p><p>存储速度是由存取时间和存取周期来表示的</p><ul><li>存取时间<br>又称为存储器的访问时间，是指从启动一次存储器操作（指读&#x2F;写）一直到完成该操作所需要花费的全部时间，所以存取时间分为读出时间和写入时间两种<ul><li>读出时间：从存储器接收有效地址开始，到产生有效输出所需的全部时间</li><li>写入时间：从存储器接收到有效地址开始，到数据写入被选中单元为止所需要的全部时间</li></ul></li><li>存取周期<ul><li><strong>指存储器连续进行两次独立的存储器操作（比如，两次读操作）所需的最小时间间隔（对一个存储单元进行第一次操作开始到完成对第二个存储单元的第二次操作之间的最小间隔）</strong>，通常来说，存取周期要大于存取时间。存取周期和存储器带宽紧密联系，存储器带宽是以存储器为中心的机器改善机器瓶颈的一个关键因素</li><li>存储器带宽<ul><li>表示单位时间内存储器存取的信息量，单位可以使用字&#x2F;秒或者字节&#x2F;秒或者位&#x2F;秒来表示</li><li>提高存储器带宽的措施：1、缩短存储周期 2、增加存储体 3、增加存储字长，使每一个存取周期可以读&#x2F;写更多的二进制位数</li></ul></li></ul></li></ul><p><strong>半导体存储芯片</strong></p><p>半导体存储芯片采用超大规模集成电路制造工艺，在一个芯片内部集成具有记忆功能的存储矩阵、译码驱动电路和读&#x2F;写电路等（与存储器相关的MAR和MDR制作在了CPU中）</p><p><strong>半导体存储芯片的基本结构</strong></p><p>存储矩阵</p><p>用于存储0、1代码的一块区域</p><p>译码驱动</p><p>负责把通过地址总线送来的地址信号翻译成对应存储单元的选择信号，该选择信号在读&#x2F;写电路的配合下即可实现对被选中存储单元的读&#x2F;写操作，即存储器的译码驱动</p><p>读&#x2F;写电路</p><p>包括放大器和写入电路，用来完成CPU对存储芯片的读&#x2F;写操作</p><p>总线</p><p>存储芯片通过地址总线、数据总线和控制总线与外部连接</p><p>地址线和数据线的位数共同反映了存储芯片的容量（类比于MAR和MDR的位数共同反映了存储体的容量），比如地址线有10根，数据线有4根，则芯片容量为（ 2^10 ）* 4，通常使用1K * 4这样的形式来表示芯片容量（4表示的是数据线个数，即存储字长的位数，1K表示的存储单元总数，每一个地址对应一个字节的空间）</p><ul><li><p>地址总线</p><ul><li><p>为单向输入总线，</p><p>  地址总线的位数与存储芯片的存储单元总数和地址总数有关</p></li></ul></li><li><p>数据总线</p><ul><li><p>为双向输入输出总线（有的芯片也会使用成对的数据线分别作为输入和输出），</p><p>  数据总线的位数和存储芯片一次可以读出或者写入的数据位数有关</p></li></ul></li><li><p>控制总线</p><ul><li>读&#x2F;写控制线<ul><li>单向输入总线，用于CPU对存储芯片实现读&#x2F;写操作</li><li>可以使用一根线进行控制：WE表示低电平尾写操作，高电平为读操作</li><li>可以使用两根线分别进行控制： OE表示进行读操作； WE表示进行写操作；</li></ul></li><li>片选线<ul><li>用来选择芯片（半导体存储器中具有许多芯片），指出本次访存操作的目标地址针对的是具体是哪个芯片</li><li>半导体存储芯片的片选线一般有两种标识方式，一个是CS，表示是否选择该芯片，一个是 CE，表示该芯片是否使能，皆为低电平有效</li></ul></li></ul></li></ul><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.27.35.png" alt="截屏2024-09-04 00.27.35.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.32.14.png" alt="截屏2024-09-04 00.32.14.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.32.27.png" alt="截屏2024-09-04 00.32.27.png"></p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.32.40.png" alt="截屏2024-09-04 00.32.40.png"></p><p><strong>片选线工作的例子：</strong></p><p>如果使用 16K x 1位 的存储芯片要组成 64K x 8位 的存储器</p><p>由于存储器中的每一个存储单元的容量为8位（一个字节），而存储芯片的存储单元的容量为1位，于是我们要将8个存储芯片看作一组，在进行存储器读&#x2F;写操作的时候，必须要同时对绑定为一组的这8个存储芯片同时进行读&#x2F;写操作，此时每一组芯片的容量为 16K X 8位，由于64为16的4倍，所以还需要增加4组这样的 16K x 1位 芯片才能满足要求，形成一个 64K X 8位 的存储器</p><p>进行地址编号分配的时候，由于同一组的8个芯片要同时工作，所以每一组共用地址数目为16K的地址编号和一根片选线（8个芯片要么全部被选中，要么全部都不被选中）。比如，当我们需要地址编号为65535（64K-1）对应存储器中的数据时，我们就会将该地址编号对应的那一组的8个存储芯片的片选信号同时置为低电平（8个存储芯片同时处于有效状态），同时其他组的芯片的片选信号全部置为高电平（其他存储芯片同时处于无效状态），从而实现仅仅对此组的8个芯片同时进行存储单元进行访问（在8个芯片相对应的同一位置的那个存储单元处同时读出一位，从而取出地址编号为65535对应存储器中的那8位数据）<br><strong>译码驱动方式（选中芯片中某一个存储单元）</strong></p><p><strong>线选法</strong></p><p>数据线有8根，表示每一个存储单元的位数有8位（一个字节）；地址线有4根，表示每一个存储单元的总数为16个，所以存储容量表示为16 * 1字节</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%2011.png" alt="Untitled"></p><p><strong>选中存储单元的方式</strong></p><ul><li>使用一根字选择线（字线），可以选中一个存储单元的所有二进制位（比如选中了一个字节，8个比特位）</li><li>比如，当地址线A3 A2 A1 A0分别为1 1 1 1时，地址译码器输出端的第15根字线有效，这一根线选中的那最后一个存储单元的8位数据就可以直接进行读&#x2F;写</li></ul><p>特点</p><ul><li>这种选中存储单元的方式结构简单，但是只适用于容量不大的存储芯片的驱动，如果地址单元数目过多，就会导致译码器输出端上连接的线数将会非常多，线路非常密集</li><li>比如有20根地址线，采用线选法，我们需要一个译码器进行译码，这样就需要在译码器的输出端连接1M根线，每一根线对应一个存储单元</li><li>本质上来说，线选法是将所有的存储单元排成一列（类似于C语言中一维数组的各个元素空间在内存中的存储方式）</li></ul><p><strong>重合法</strong></p><p>数据线只有一根，表示每一个存储单元的位数只有一位；地址线有10根，表示每一个存储单元的总数为 1K 个，所以存储容量表示为 1K * 1位</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.36.45.png" alt="截屏2024-09-04 00.36.45.png"></p><p>选中存储单元的方式</p><p>对于图中的矩阵，使用了64根线（X，Y两个方向的译码器输出端各具有32根），与线选法不同的是此时每一个存储单元具有行、列两个地址，通过确定行、列地址，即可实现对该 32X32 矩阵的中每一个存储单元的访问（只有当一个存储单元的行地址和列地址都被选中时，才能对该存储单元进行访问）</p><p>比如，当地址线全为 0 的时候（即A9 A8 … A0全部为0），两个译码器输出 X0 和 Y0 有效，对应于矩阵中 0 行 0 列的那个存储单元被选中，只有这个存储单元才能进行数据的输入和输出<br>特点</p><p>实际上，在重合法中，在进行读操作的时候，被选中的行和列中的其他存储单元，自身也会进行数据输出，但是都不会到达I&#x2F;O读写结构处，只有当一个存储单元的行地址和列地址都被选中时，才能让存储单元中的数据成功到达I&#x2F;O读写结构处。类似地，进行写操作的时候也是因为是否具有通路的问题，而导致只有那个行地址和列地址同时被选中的那个存储单元，才能实现数据的输入</p><p>比如有20根地址线，采用重合法，我们需要两个译码器进行译码，这两个译码器的输入端分别连接10根地址线，则在译码器的输出端一共就可以产生2K根线，每两根相互垂直的线即可选中一个存储单元，这种方式相对于线选法节省了大量的线</p><p>本质来说，重合法是将所有的存储单元排成一个矩阵，只有将行地址和列地址进行组合，才是一个存储单元的完整地址</p><p>使用重合法进行存储单元选定的例子：</p><p>如何使用重合法实现一个容量为 1K X 4位 的存储器</p><p>一个 1K x 4位 的存储器表示每一个存储单元的位数为4，即我们要把4个基本单元电路（每一个基本单元电路本身可以存储一位比特位的数据）作为一组，同时要实现一根列线控制4个基本单元同时读&#x2F;写有效，此时1K表示具有1024（210）个存储单元，又每一个存储单元为4位，于是需要26*26个基本单元电路（一个相互垂直的线选中一个基本单元电路）<br>那么我们可以将这些基本单元电路排布为一个 64 x 64 的矩阵，由于要实现的是一个列选信号同时控制4个基本单元电路，于是我们对应列地址的译码采用4个输入端，16个输出端的译码器，实现每一个输出端控制4列，而行地址依旧使用6个输入端，64个输出端的译码器，这样就可以实现：只要给出一个地址编号，就会同时有4个基本单元电路被选中</p><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%2012.png" alt="Untitled"></p><p><strong>随机存储器（RAM）</strong></p><p><strong>静态RAM（SRAM）</strong></p><p><strong>静态RAM基本单元电路</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成原理&quot;&gt;&lt;a href=&quot;#计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理&quot;&gt;&lt;/a&gt;计算机组成原理&lt;/h1&gt;&lt;h1 id=&quot;1-概论&quot;&gt;&lt;a href=&quot;#1-概论&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="http://example.com/2024/09/24/part1/"/>
    <id>http://example.com/2024/09/24/part1/</id>
    <published>2024-09-24T02:30:41.398Z</published>
    <updated>2024-09-24T02:30:41.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一篇测试文章"><a href="#这是一篇测试文章" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一篇测试文章&quot;&gt;&lt;a href=&quot;#这是一篇测试文章&quot; class=&quot;headerlink&quot; title=&quot;这是一篇测试文章&quot;&gt;&lt;/a&gt;这是一篇测试文章&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客维护</title>
    <link href="http://example.com/2024/09/24/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    <id>http://example.com/2024/09/24/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/</id>
    <published>2024-09-24T02:25:35.298Z</published>
    <updated>2024-09-27T06:48:11.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客维护"><a href="#博客维护" class="headerlink" title="博客维护"></a>博客维护</h1><p><a href="https://www.cnblogs.com/yzhihao/p/6964208.html"><strong>Hexo 搭建博客 本地运行 常见报错及解决办法</strong></a></p><p>作为一名在hexo方面的新手，我在使用hexo编辑文档时遇到了很多问题，<code>hexo generate</code>编译的时候遇到了各种错误。</p><p>在此将这些错误及其解决方案记录下来，以便日后查证之用，同时，也可给各位在遇到类似问题时提供一点参考。</p><p><code>1</code>.<strong>执行命令hexo server，提示：Usage: hexo …. 提示找不到该指令</strong></p><p>解决方法，在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：npm install hexo-server –save 安装此server后再试，问题解决。</p><p><code>2</code>.<strong>执行：hexo server，启动了服务，在浏览器输入本地地址访问，看到白板和Cannot GET &#x2F; 几个字</strong></p><p><strong>方法一 有时无效</strong></p><p>原因是由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-ejs--save</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-stylus--save</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-marked--save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方法二 亲测有效</strong></p><p>创建一个空文件夹，</p><p>依次执行如下命令就行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init projectName(你的项目文件名）</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> 项目到空文件夹下（一定要先hexo init 再 git <span class="built_in">clone</span> 项目）</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> projectName</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><strong>3.localhost:4000 端口被占用，可执行 hexo s -p 5000 修改成5000 端口</strong></p><p><strong>4.YAMLException: end of the stream or a document separator is expected at line x, column y:</strong></p><h3 id="错误说明"><a href="#错误说明" class="headerlink" title="错误说明"></a><strong>错误说明</strong></h3><p>缺少分隔符，一般都是因为缺少空格</p><p><strong>解决方案</strong></p><p>（1）出现这种情况，一般都是缺少空格，在<code>:</code>冒号之后要有空格！检查x行y列附近的冒号，其之后是否跟了空格。</p><p>（2）仔细检查<code>_config.yml</code>文件中所有冒号后面的空格，格式很严格，必须是只有一个，半角。不管是多了还是少了都会报错，这是yml解释器所定义的语法。如果不确定的话，将输入法调整到英文模式，删除所有冒号后面的空格重新输入，不要使用Tab。</p><p><strong>5.ValidationError: ‘null’ is not a string!</strong></p><h3 id="错误说明-1"><a href="#错误说明-1" class="headerlink" title="错误说明"></a><strong>错误说明</strong></h3><p>一般都是因为文章无内容，可能是因为在这篇博客文章中，有某些属性没有填写，比如author属性，tag属性，categories属性等，导致该属性是空的，即<code>null</code>，所以报错。</p><p>友情提示：如果你是用MarkdownPad 2来进行博文写作，可能在打开该md文件之后，对文件名进行了修改，导致出现了两篇文章。就会出现错误。</p><p> <strong>解决方案</strong></p><p>既然是属性缺失，那就把为空的那个属性给补上吧，仔细找找</p><p><strong>6.执行hexo g命令后，报错：<code>incomplete explicit mapping pair; a key node is missed</code></strong></p><p><strong>解决方案：</strong></p><p>主题目录下所有yml文件中所有有空格的字段都用双引号括起来，尤其注意languages下面的yml文件。</p><p>上传markdown文件至博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">清理项目缓存</span><br><span class="line">hexo clean</span><br><span class="line">重新生成博客</span><br><span class="line">hexo g</span><br><span class="line">将文件中的markdown文件转化为静态网页html文件</span><br><span class="line">hexo s</span><br><span class="line">部署到云端（github）</span><br><span class="line">hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多端开发"><a href="#多端开发" class="headerlink" title="多端开发"></a>多端开发</h2><p><a href="https://github.com/naosense/naosense.github.io/discussions/9">一套全平台多端发布hexo博文的方法 · naosense naosense.github.io · Discussion #9</a></p><p><a href="https://cloud.tencent.com/developer/article/1365689">如何多端同步 Hexo 框架博客-腾讯云开发者社区-腾讯云</a></p><p><a href="https://blog.csdn.net/ch206265/article/details/103239545#:~:text=%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93Hexo%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%92%8C%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%9C%E8%A5%BF%E3%80%82%20%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%98%AF%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%E5%8C%85%E6%8B%AC%E4%BA%86%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E7%9A%84MarkDown%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%BB%E9%A2%98%E6%96%87%E4%BB%B6%E7%AD%89%E7%AD%89%EF%BC%9B%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%80%E7%BB%88%E8%AE%BF%E9%97%AEGitHubName.github.io%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E8%BF%99%E4%BA%9B%E4%BF%9D%E5%AD%98%E5%9C%A8GitHub%E4%B8%AD%E6%B8%B2%E6%9F%93%E8%BF%87%E7%9A%84%E4%B8%9C%E8%A5%BF%E3%80%82,%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E8%AE%A9%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%BD%E6%9C%89%E6%9C%80%E6%96%B0%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E9%82%A3%E4%B8%AA%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8git%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%80%E9%9C%80%E6%B1%82%E3%80%82%20%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%E6%98%AF%EF%BC%9A%20%E5%88%B0GitHubName.github.io%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%EF%BC%8C%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF%E5%91%BD%E5%90%8D%E4%B8%BAhexo%EF%BC%88%E8%BF%99%E4%B8%AA%E6%96%B0%E5%BB%BA%E7%9A%84branch%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E5%AD%98%E5%82%A8%E6%9C%AC%E5%9C%B0%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E5%B9%B6%E5%B0%86%E6%96%B0%E5%BB%BA%E7%9A%84hexo%E5%88%86%E6%94%AF%E8%AE%BE%E7%BD%AE%E4%B8%BAdefault%E5%88%86%E6%94%AF%EF%BC%9B">利用GitHub实现Hexo博客的多端同步_hexo github 第二台电脑-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/0b1fccce74e0"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客维护&quot;&gt;&lt;a href=&quot;#博客维护&quot; class=&quot;headerlink&quot; title=&quot;博客维护&quot;&gt;&lt;/a&gt;博客维护&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yzhihao/p/6964208.html&quot;&gt;&lt;stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学生手册</title>
    <link href="http://example.com/2024/09/24/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2%E7%9A%84%E5%AD%A6%E6%9C%AF%E8%AF%9A%E4%BF%A1-%E5%AD%A6%E7%94%9F%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/2024/09/24/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2%E7%9A%84%E5%AD%A6%E6%9C%AF%E8%AF%9A%E4%BF%A1-%E5%AD%A6%E7%94%9F%E6%89%8B%E5%86%8C/</id>
    <published>2024-09-23T19:29:56.000Z</published>
    <updated>2024-09-27T06:59:35.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="麻省理工学院的学术诚信-学生手册"><a href="#麻省理工学院的学术诚信-学生手册" class="headerlink" title="麻省理工学院的学术诚信-学生手册"></a>麻省理工学院的学术诚信-学生手册</h1><h2 id="麻省理工学院的学术诚信"><a href="#麻省理工学院的学术诚信" class="headerlink" title="麻省理工学院的学术诚信"></a>麻省理工学院的学术诚信</h2><h2 id="引用你的来源"><a href="#引用你的来源" class="headerlink" title="引用你的来源"></a>引用你的来源</h2><h2 id="学术写作"><a href="#学术写作" class="headerlink" title="学术写作"></a>学术写作</h2><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><h2 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h2><h2 id="欺骗"><a href="#欺骗" class="headerlink" title="欺骗"></a>欺骗</h2><h2 id="在压力下工作"><a href="#在压力下工作" class="headerlink" title="在压力下工作"></a>在压力下工作</h2><h2 id="帮助你成功"><a href="#帮助你成功" class="headerlink" title="帮助你成功"></a>帮助你成功</h2><h2 id="学术诚信手册"><a href="#学术诚信手册" class="headerlink" title="学术诚信手册"></a>学术诚信手册</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;麻省理工学院的学术诚信-学生手册&quot;&gt;&lt;a href=&quot;#麻省理工学院的学术诚信-学生手册&quot; class=&quot;headerlink&quot; title=&quot;麻省理工学院的学术诚信-学生手册&quot;&gt;&lt;/a&gt;麻省理工学院的学术诚信-学生手册&lt;/h1&gt;&lt;h2 id=&quot;麻省理工学院的学术</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="http://example.com/2024/09/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2024/09/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</id>
    <published>2024-09-06T19:14:37.000Z</published>
    <updated>2024-09-06T19:14:37.198Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/09/07/hello-world/"/>
    <id>http://example.com/2024/09/07/hello-world/</id>
    <published>2024-09-06T19:05:35.189Z</published>
    <updated>2024-09-06T19:05:35.189Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
