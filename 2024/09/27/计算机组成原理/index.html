<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机组成原理 | heguang_blog</title><meta name="author" content="heguang123456"><meta name="copyright" content="heguang123456"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机组成原理1. 概论 （1）计算机系统概论计算机系统由“硬件”和“软件”组成， 硬件指的是计算机的实体部分，如主机、外部设备等软件通常分为两大类：系统软件和应用软件。 系统软件又称为系统程序，主要用来管理整个计算机系统。包括标准程序库、语言处理程序（如将汇编语言翻译成机器语言的汇编程序和将高级语言译成机器语言的编译程序）、操作系统（如批处理系统、分时系统、实时系统）、服务程序（如诊断程序、调试">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="http://example.com/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="heguang_blog">
<meta property="og:description" content="计算机组成原理1. 概论 （1）计算机系统概论计算机系统由“硬件”和“软件”组成， 硬件指的是计算机的实体部分，如主机、外部设备等软件通常分为两大类：系统软件和应用软件。 系统软件又称为系统程序，主要用来管理整个计算机系统。包括标准程序库、语言处理程序（如将汇编语言翻译成机器语言的汇编程序和将高级语言译成机器语言的编译程序）、操作系统（如批处理系统、分时系统、实时系统）、服务程序（如诊断程序、调试">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-09-26T22:11:58.000Z">
<meta property="article:modified_time" content="2024-09-27T07:11:26.294Z">
<meta property="article:author" content="heguang123456">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机组成原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-27 15:11:26'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="heguang_blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="heguang_blog"><span class="site-name">heguang_blog</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">计算机组成原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-26T22:11:58.000Z" title="Created 2024-09-27 06:11:58">2024-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-27T07:11:26.294Z" title="Updated 2024-09-27 15:11:26">2024-09-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机组成原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1. 概论"></a>1. 概论</h1><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/0101.jpg" alt="0101.jpg"></p>
<h2 id="（1）计算机系统概论"><a href="#（1）计算机系统概论" class="headerlink" title="（1）计算机系统概论"></a>（1）计算机系统概论</h2><p>计算机系统由“硬件”和“软件”组成，</p>
<p>硬件指的是计算机的实体部分，如主机、外部设备等软件通常分为两大类：系统软件和应用软件。</p>
<p>系统软件又称为系统程序，主要用来管理整个计算机系统。包括标准程序库、语言处理程序（如将汇编语言翻译成机器语言的汇编程序和将高级语言译成机器语言的编译程序）、操作系统（如批处理系统、分时系统、实时系统）、服务程序（如诊断程序、调试程序、连接程序等）、数据库管理系统、网络系统等。</p>
<p>应用软件又称为应用程序，它是用户根据需要所编制的各种程序、如科学计算程序、数据处理程序、过程控制程序、事务管理程序等。 </p>
<p>计算机解题过程通常由用户用高级语言编写程序（称为源程序），然后它和数据一起送入计算机，再由计算机将其翻译成机器能识别的机器语言程序（称为目标程序），机器自动运行该机器语言程序，并输出计算结果。</p>
<p>实际上，早期的计算机只有机器语言（用0、1代表示的语言），用户必须用二进制代码来编写程序（即机器语言程序）</p>
<p>上世纪50年代出现了符号式的程序设计语言，即<strong>汇编语言</strong>。它用符号ADD、SUB、MUL、DIV等分别表示加减乘除，并用符号表示指令或数据所在存储单元的地址。但实际上，没有一种机器能够直接识别这种汇编语言程序，必须先将汇编语言程序翻译成机器语言程序，然后才能被机器接受并自动运行。</p>
<p>上世纪60年代出现了各种面向问题的<strong>高级语言</strong>，如FORTRAN、BASIC、Pascal、C等。机器必须先将高级语言程序翻译成汇编语言程序。然后将其翻译成机器语言程序；也可以将高级语言程序直接翻译成机器语言程序。</p>
<p>通常，将高级语言程序翻译成机器语言成的软件称为翻译程序。翻译程序由两种：一种是编译程序，另一种是解释程序。<strong>编译程序</strong>是将用户编写的高级语言程序（源程序）的全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序。如FORTRAN、Pascel等语言。<strong>解释程序</strong>是将源程序的一条语句翻译成对应于机器语言的一条语句，并且立即执行这条语句，接着翻译源程序的下一句，并执行这条语句，如此重复直至完成源程序的全部翻译任务。如BASIC语言的翻译就有解释程序和编译程序两种。</p>
<p><strong>计算机体系结构</strong>是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。计算机系统的属性通常是指用机器语言编程的程序员（也包括汇编语言程序设计者和汇编程序设计者）所看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术、I&#x2F;O机理等，大都属于抽象的属性。</p>
<p><strong>计算机组成</strong>是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。如组成计算机系统的各个功能部件的结构和功能，及相互连接方法，如指令系统体现了机器的属性，这是属于<strong>计算机结构</strong>的问题。</p>
<p>但指令的实现，即如何取细节、分析指令、取操作数、运算、送结果等这些都属于<strong>计算机组成</strong>问题。</p>
<p>冯诺依曼机的特点：</p>
<ul>
<li>计算机由运算器、存储器、控制器、输入设备和输出设备两大组成。</li>
<li>指令和数据以同等地位存放于存储器内，并可按地址寻访</li>
<li>指令和数据均用二进制数表示</li>
<li>指令由操作码和地址码组成，操作码用来表示操作的性质、地址码用来表示操作数在存储器中的位置</li>
<li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结构或根据设定的条件改变执行顺序</li>
<li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li>
</ul>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/424f8cc2b46d7c8b311591477b7d54d.jpg" alt="424f8cc2b46d7c8b311591477b7d54d.jpg"></p>
<ul>
<li>运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内。</li>
<li>存储器用来存放数据和程序</li>
<li>控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果</li>
<li>输入设备用来将人们的熟悉的信息形式转换为机器能识别的信息形式，常见的由键盘、鼠标等</li>
<li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。</li>
</ul>
<p>通常把<strong>运算器</strong>和<strong>结构器</strong>合起来统称为<strong>中央处理器（Central Processing Unit，CPU）</strong>。把输入设备与输出设备简称为 I&#x2F;O 设备（Input&#x2F;Output Equipment）。</p>
<p>现代计算机可认为由三大部分组成：<strong>CPU、I&#x2F;O设备</strong>及<strong>主存储器（Main Memory，MM）</strong>，如图1.9所示。CPU与主存储器合起来又称为主机，I&#x2F;O设备又可称为外部设备。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/49b5503a8566006e01218d39f675da2.jpg" alt="49b5503a8566006e01218d39f675da2.jpg"></p>
<p><strong>主存储器</strong>是存储器子系统中的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类称为辅助存储器。简称辅存，又称外存。</p>
<p>**主机:**是计算机硬件的主体部分，由CPU和主存储器MM合成为主机。<br>**主存:**计算机中存放正在运行的程序和数据的存储器，为计算机的主要工作存储器，可随机存取;由存储体、各种逻辑部件及控制电路组成。<br>**存储单元:**可存放一个机器字并具有特定存储地址的存储单位。<br>**存储元件:**存储一位二进制信息的物理元件，是存储器中最小的存储单位，又叫存储基元或存储元，不能单独存取。<br>**机器字长:**指CPU一次能处理的二进制数据的位数，通常与CPU的寄存器位数有关。 </p>
<p><strong>指令字长</strong>:一条指令的二进制代码位数。<br>**存储字长:**一个存储单元所存二进制代码的位数。一般与机器字长相等（准64位机与准32位机例外。例如准64位机机器字长64位、存储字长32位）<br>**存储容量:**存储器中可存二进制代码的总量;(通常主、辅存容量分开描述)。</p>
<p><strong>存储容量 &#x3D; 存储单元个数（由地址总线的数量决定） x  存储字长（和数据总线的数量一致）</strong><br><strong>存储基元</strong>是计算机内部存储的最小信息单位，也称为<strong>存储元件</strong>或<strong>存储元素</strong>。它代表了计算机存储系统中的最小数据单位，可以存储二进制数字0或1。每个存储基元都有一个唯一的地址，可以通过这个地址访问和读取其中的数据。<strong>存储元</strong>是计算机存储体系中的基本组成单位，用于存储二进制数据。存储元可以是电阻、电容、晶体管、集成电路等基本元件，也可以是专门设计的存储器件，<br><strong>存储字</strong>是指计算机存储体系中的最小数据单位，也称为<strong>存储元</strong>或<strong>存储元素</strong>。它代表了计算机存储系统中的最小数据单位，可以存储二进制数字0或1。<br><strong>指令字长</strong>是指机器指令中包含的二进制代码的总位数，也称为有效字长。它取决于从操作码的长度、操作数地址的长度和操作数地址的个数。在不同的计算机系统中，指令字长可能不同。</p>
<p><strong>算术逻辑单元（Arithmetic Logic Unit，ALU）</strong>简称算逻部件，用来完成算术逻辑运算。</p>
<p><strong>控制单元（Control Unit，CU）</strong>用来解释存储器中的指令，并发出各种操作命令来执行指令。ALU和CU是CPU的核心部件。I&#x2F;O设备也受CU控制，用来完成相应的输入、输出操作。</p>
<p><strong>程序计数器（PC，Program counter）</strong>，用于存放指令的地址。</p>
<p><strong>指令寄存器（IR，Instruction Register）</strong>，用来保存当前正在执行的一条指令。</p>
<p><strong>通用寄存器（GR，General register），</strong>通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。</p>
<p><strong>累加器（ACC，Accumulator），</strong>是运算器中既能存放运算前的操作数，又能存放运算结果的寄存器。</p>
<p><strong>乘商寄存器（MQ，Multiplier-Quotient Register）</strong>，乘法运算时存放乘数、除法时存放商的寄存器。</p>
<p><strong>X:此字母没有专指的缩写含义，</strong>可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来存放操作数;<br><strong>存储器地址寄存器（MAR:Memory Address Register）</strong>，在主存中用来存放欲访问的存储单元的地址。</p>
<p><strong>存储器数据缓冲寄存器（MDR:Memory Data Register）</strong>，在主存中用来存放从某单元读出、或要写入某存储单元的数据。</p>
<p><strong>每秒执行百万条指令数（MIPS:Million Instruction Per Second）</strong>，为计算机运算速度指标的一种计量单位。</p>
<p><strong>CPI（Clock cycle Per Instrucion）</strong>：执行一条指令所需的时钟周期数<br><strong>执行一条指令的耗时 &#x3D; CPI x CPU时钟周期</strong></p>
<p><strong>CPU执行时间&#x3D; CPU时钟周期数&#x2F;主频&#x3D; （指令条数*CPI）&#x2F;主频</strong></p>
<p>**IPS（Instructions Per Second）[KIPS、MIPS]**：每秒执行多少条指令</p>
<p>**FLOPS（Floatin-point Operations Per Second）[KFLOPS、MFLOPS、GFLOPS、TFLOPS]**：每秒执行多少次浮点运算</p>
<p>K&#x3D;Kilo&#x3D;千&#x3D;10的3次方，M&#x3D;Million&#x3D;百万&#x3D;10的4次方，G&#x3D;Glga&#x3D;十亿&#x3D;10的九次方，T&#x3D;Tera&#x3D;万亿&#x3D;10的12次方</p>
<p><strong>计算机区分存储器中的指令和数据主要有两种方法：</strong></p>
<p>方式一：通过不同时间段来区分指令和数据，即在取指令阶段（或取值微指令）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。</p>
<p>方式二：通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。</p>
<p>存储器中的每段存储空间都会有一个地址，每个指令都包括一段操作数和一段空间地址，cpu会根据操作数去处理地址所指的数据。一般计算机先读取存储器最开始的内容（这一部分是指令），然后加载操作系统后由操作系统对硬盘文件系统结构（即是数据）以判断其他数据和指令的位置。<br><strong>什么是指令？什么是数据？</strong></p>
<p>指令：指令是指计算机执行某种操作的命令，它由一串二进制数码组成。计算机执行了一指令序列，便可完成预定的任务，这一指令序列就称为程序；<br>程序：一系列指令的有序集合称为程序<br>指令的执行过程分为四步：1.取指令；2.分析指令；3.执行指令；4.完成上述操作后，指令计数器加1，为执行下一条指令做准备。</p>
<h3 id="1-3计算机的工作步骤"><a href="#1-3计算机的工作步骤" class="headerlink" title="1.3计算机的工作步骤"></a><strong>1.3计算机的工作步骤</strong></h3><p><strong>1、建立数学模型</strong></p>
<p><strong>2、确定计算方法</strong></p>
<p><strong>3、编制解题程序：将运算步骤用一一对应的机器指令描述</strong></p>
<p><strong>（1）预备知识</strong></p>
<ul>
<li>操作码（6位：表示机器所执行的各种操作，如取数、存数、加、减、乘、除、停机、打印等。</li>
<li>地址码（10位：表示参加运算的数在存储器内的位置。机器指令的操作码和地址码都采用0、1代码的组合来表示。</li>
<li>指令格式举例：</li>
</ul>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image.png" alt="image.png"></p>
<ul>
<li><p>操作码举例：<br>000001 取数（将指令地址指示的存储单元中的操作数取到运算器的累加器ACC中）、000010 存数（将ACC中的数存至地址码知识的存储单元中）、000011 加（将ACC中的数与指令地址码指示的存储单元的数相加，结果存于ACC中）、000100 乘（将ACC中的数与指令地址码指示的存储单元的数相乘，结果存于ACC中）、000101 打印（将指令地址码指示的存储单元的数打印输出）、000110 停机</p>
<p>  <strong>（2）计算机组成框架</strong></p>
<p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%201.png" alt="image.png"></p>
</li>
<li><p>主存储器（简称主存&#x2F;内存<br>-包含若干存储单元，每个存储单元包含若干存储元件，每个存储元件可以寄存一位二进制代码“0”“1”等。<br>-配置两个寄存器MAR和MDR。<br>-MAR为存储器地址寄存器，用来存放欲访问的存储单元的地址，位数对应存储单元的个数。<br>-MDR是存储器数据寄存器，用来存放从存储体某单元取出的代码或者准备往某存储单元存入的代码，七位数与存储字长相等。</p>
</li>
</ul>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%202.png" alt="image.png"></p>
<ul>
<li><p>运算器</p>
<p>  至少包括三个寄存器+一个算术逻辑单元ALU</p>
<p>  三个寄存器：ACC 累加器、MQ 乘商寄存器、X操作数寄存器</p>
<p>  各个寄存器所存放的各类操作数</p>
<p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%203.png" alt="image.png"></p>
</li>
</ul>
<p>（M为存储器的任一地址号、[M]为地址号中的内容）</p>
<p>加法操作过程：</p>
<p>1.[M]-&gt;X 先从主存中取加数[M]，送至运算器的X寄存器中</p>
<ol start="2">
<li>[ACC]+[X]-&gt;ACC 将ACC中的被加数与加数结果存入累加器中</li>
</ol>
<p>控制器</p>
<ul>
<li>由程序控制器&#x2F;PC （顺序执行）、指令寄存器&#x2F;IR（操作码、地址码）、控制单元&#x2F;CU（对操作码中的指令进行译码分析）组成，用来解释指令&#x2F;保证指令的按序执行</li>
<li>单目操作符不需要访问内存</li>
</ul>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%204.png" alt="image.png"></p>
<p><strong>1.9 画出主机框图，分别以存数指令“STA M”和加法指令“ADD M”（M均为主存地址）为例，在图中按序标出完成该指令（包括取指阶段）的信息流程。假设主存容量为256M*32位，在指令字长、存储字长、机器字长相等的条件下，指出图中各寄存器的位数。</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%205.png" alt="image.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%206.png" alt="image.png"></p>
<h2 id="（2）计算机的发展史及应用"><a href="#（2）计算机的发展史及应用" class="headerlink" title="（2）计算机的发展史及应用"></a>（2）计算机的发展史及应用</h2><p>1.第一代电子管计算机<br>第一代电子管计算机——ENIAC(The Electronic Numerical Integrator And Computer)，1946年在费城公诸于世，它通过不同部分之间的重新接线编程，还拥有并行计算能力，但功能受限制，速度也慢。ENIAC的问世标志现代计算机的诞生，是计算机发展史上的里程碑<br>2.第二代晶体管计算机<br>第二代晶体管计算机 晶体管的发明大大促进计算机的发展，晶体管代替电子管，电子设备体积减小。1956年，晶体管在计算机中使用，晶体管和磁芯存储器导致了第二代计算机的产生。第二代计算机体积小、速度快、功耗低、性能更稳定。首先使用晶体管技术的是早期的超级计算机，主要用于原子科学的大量数据处理，这些机器价格昂贵，生产数量极少。<br>3.第三代集成电路计算机<br>第三代集成电路计算机 晶体管比起电子管进步，但产生的大量热量损害计算机内部的敏感部分。1958年发明了集成电路(IC)，将电子元件结合到一片小小的硅片上，使更多的元件集成到单一的半导体芯片上。于是，计算机变得更小，功耗更低，速度更快。这一时期的发展还包括使用了操作系统，使计算机在中心程序的控制协调下可以同时运行许多不同的程序。1964年，美国IBM公司研制成功第一个采用集成电路的通用电子计算机系列IBM360系统。<br>4.第四代大规模集成电路计算机<br>第四代大规模集成电路计算机 大规模集成电路(LSI)可以在一个芯片上容纳几百个元件。到了80年代，超大规模集成电路(VLSI)在芯片上容纳了几十万个元件，后来的ULSI将数字扩充到百万级。可以在硬币大小的芯片上容纳如此数量的元件使得计算机的体积和价格不断下降，而功能和可靠性不断增强。基于“半导体”的发展，到了一九七二年，第一部真正的个人计算机诞生了。<br>5.第五代智能计算机<br>第五代智能计算机 1981年，在日本东京召开了第五代计算机研讨会，随后制订出研制第五代计算机的长期计划。智能计算机主要特征是具备人工智能，能像人一样思考，并且运算速度极快，其硬件系统支持高度并行和推理，其软件系统能够处理知识信息。神经网络计算机（也称神经元计算机）是智能计算机的重要代表。但第五代计算机目前仍处在探索、研制阶段。真正实现后,将有无量的发展前途,它的前景,必将是光辉诱人的。<br>6.第六代生物计算机<br>第六代生物计算机 半导体硅晶片的电路密集，散热问题难以彻底解决，影响了计算机性能的进一步突破。研究发现，DNA的双螺旋结构能容纳巨量信息，其存储量相当于半导体芯片的数百万倍。一个蛋白质分子就是存储体，而且阻抗低、能耗小、发热量极低。基于此，利用蛋白质分子制造出基因芯片研制生物计算机，已成为当今计算机技术的最前沿。生物计算机比硅晶片计算机在速度、性能上有质的飞跃，被视为极具发展潜力的“第六代计算机”。</p>
<hr>
<p>2.3计算机的展望<br>分子计算机：分子计算机的运算速度是目前计算机的1000亿倍，最终将会取代硅芯片计算机。</p>
<p>量子计算机：量子力学证明，个体光子通常不相互作用，但是当它们与光学谐腔内的原子聚在一起时，它们相互之间会产生强烈的影响。光子的这种特性可用来发展量子力学效应的信息处理器件—光学量子逻辑门，进而制造出量子计算机。</p>
<p>DNA计算机： 科学家研究发现，脱氧核糖核酸有一种特性，能够携带生物体的大量基因物质。数学家、生物学家、化学家以及计算机专家从中获得启迪，正在合作研制未来的液晶DNA电脑。</p>
<p>神经元计算机：将来，人们制造能够完成类似人脑功能的计算机系统，即人造神经元网络。神经元计算机最有前途的应用是国防：它可以识别物体和目标，处理复杂的雷达信号，决定要击毁的目标。神经元计算机的联想式信息存储、对学习的自然适应性、数据处理等性能都异常有效。</p>
<p>生物计算机：生物计算机主要是以生物电子元件构建的计算机。它利用蛋白质的开关特性，用蛋白质分子作为元件从而制成的生物芯片。其性能是由元件与元件之间的电流启闭开关速度来决定的。由蛋白质构成的集成电路，其运行速度非常快，大大超过了人脑的思维速度。</p>
<ol>
<li>通常计算机的更新换代以什么为依据？<br>答： 主要以组成计算机基本电路的元器件为依据，如电子管、晶体管、集成电路等。</li>
<li>举例说明专用计算机和通用计算机的区别。<br>答：按照计算机的效率、速度、价格和运行的经济性和实用性可以将计算机划分为通用计算机和专用计算机。通用计算机适应性强，但牺牲了效率、速度和经济性，而专用计算机是最有效、最经济和最快的计算机，但适应性很差。例如个人电脑和计算器。</li>
<li>什么是摩尔定律？该定律是否永远生效？为什么？<br>摩尔定律是由英特尔创始人之一戈登·摩尔提出来的。其内容为：积体电路上可容纳的电晶体（晶体管）数目，约每隔两年便会增加一倍；经常被引用的“18个月”，是由英特尔首席执行官大卫·豪斯所说：预计18个月会将芯片的性能提高一倍（即更多的晶体管使其更快）。<br>该定律不会一直生效。原因有：其一，硅芯片的集成度要受其物理极限的制约，集成度不可能永无止境的提高；其二由于芯片集成度提高时，其制作成本也在不断提高；其三，随着集成度的提高，微处理器内部的功耗、散热、线延迟等一系列的问题将难以解决。</li>
</ol>
<h1 id="2-计算机系统的硬件结构"><a href="#2-计算机系统的硬件结构" class="headerlink" title="2. 计算机系统的硬件结构"></a>2. 计算机系统的硬件结构</h1><h2 id="（3）系统总线"><a href="#（3）系统总线" class="headerlink" title="（3）系统总线"></a>（3）系统总线</h2><p>计算机系统的五大部件之间的互连方式有两种，一种是各部件之间使用单独的连线，称为分散连接；另一种是将各部件连到一组公共信息传输线上，称为总线连接。</p>
<p>随着I&#x2F;O设备的种类和数量越来越多，分散连接不利于人们随时增添或减撤设备，硬件复杂度上升，由此出现了总线连接。</p>
<p><strong>总线是连接多个部件的信息传输线，是各部件共享的传输介质</strong>。当多个部件与总线相连时，如果出现两个或两个以上部件同时向总线发送信息，势必导致信号冲突，传输无效。因此，在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。</p>
<p>总线实际上是由许多传输线或通路组成，每条线可一位一位地传输二进制代码，一串二进制代码可在一段时间内逐一传输完成。若干条传输线可以同时传输若干位二进制代码，例如，16条传输线组成的总线可同时传输16位二进制代码。</p>
<p><strong>最简单的输入接口是三态门，最简单的输出接口是锁存器寄存器。</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/01623ba16705d741b6ff1cd3db5301d.jpg" alt="01623ba16705d741b6ff1cd3db5301d.jpg"></p>
<p>它是在单总线基础上又开辟出的一条CPU与主存之间的总线，称为存储总线。这跟总线速度高，只供主存与CPU之间传输信息。这样既提高了传输效率，又减轻了系统总线的负担，还保留了I&#x2F;O设备与存储器交换信息时不经过CPU的特点。现代计算机大多数采用各类总线结构。</p>
<p><strong>总线分类</strong></p>
<p>按数据传送方式可分为并行传输总线和穿行传输总线，在并行传输总线中，又可按传输数据宽度分为8位，16位，32位，64位等传输总线。若按总线的使用范围划分，则又有计算机（包括外设）总线、测控总线。</p>
<p><strong>片内总线</strong></p>
<p>片内总线是指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间，寄存器与算逻单元ALU之间都由片内总线连接。</p>
<h3 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a><strong>系统总线</strong></h3><p>系统总线是指CPU、主存、I&#x2F;O设备（通过I&#x2F;O接口）各大部件之间的信息传输线。由于这些部件通常都安放在主板或各个插件版上（插卡）上，故又称版级总线（在一块电路板上个芯片间的连线）或版间总线。</p>
<p>按系统总线传输信息的不同，又可分为三类：数据总线、地址总线和控制总线。</p>
<p>1、数据总线(DB)双向用来传输各功能部件之间的数据信息，它是<strong>双向</strong>传输总线，其位数与机器字长、存储字长有关（不一定一致，有例外）。</p>
<p>2、地址总线(AB)用来指出数据总线上的源数据或目的数据所在的主存单元或 I&#x2F;O 端口的地址，它是<strong>单向</strong>传输总线，地址总线的位数与主存地址空间的大小有关。决定存储单元个数</p>
<p>3、 控制总线(CB)传输的是控制信息,包括 CPU 送出的控制命令和主存(或外设)返回 CPT的反馈信号。存储器读写、总线允许、中断确认。有输入有输出。</p>
<ul>
<li><p><strong>常见的控制信号：</strong></p>
<p>  时钟：用来同步各种操作</p>
<p>  复位：用来初始化所有部件</p>
<p>  总线请求：表示某部件需获得总线使用权</p>
<p>  总线允许：表示需要获得总线使用权的部件已获得了控制权</p>
<p>  中断请求：表示某部件提出中断请求</p>
<p>  中断响应：表示中断请求已被接受</p>
<p>  存储器写：将数据总线上的数据写至存储器的指定地址单元内</p>
<p>  I&#x2F;O读：从指定的I&#x2F;O端口将数据读到数据总线上</p>
<p>  I&#x2F;O写：将数据总线上的数据输出到指定的I&#x2F;O端口内</p>
<p>  传输响应：表示数据已被接收，或已将数据送至数据总线上</p>
</li>
</ul>
<h3 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h3><p>这类总线用于<strong>计算机系统之间</strong>或<strong>计算机系统与其他系统</strong>（如控制仪表，移动通信等）之间的通信。按传输方式可分为两种：串行通信和并行通信</p>
<p>串行通信（不同设备）是指数据在单条1位宽的传输线上，一位一位地按顺序分时传送。</p>
<p>并行通信是指数据在多条并行1位宽的传输线上，同时由源传送到目的地。</p>
<p>采用串行通信费用远比并行通信费用低得多，此外串行通信还可利用现有的电话网络来实现远程通信，降低通信费用，但是在数据发送和接收的时候，要进行拆卸和装配，要考虑串行、并行转换的问题。 </p>
<aside>
❓ （1）总线宽度是一次总线操作中，最多可传递的数据位数。

<p>（2）总线周期是一次总线操作所需要的最小间隔时间。总线周期与总线的时钟频率成反比，即T&#x3D;1&#x2F;f。</p>
<p>3）总线宽度是单位时间内通过总线的数据位数，总线的数据传输率，单位为MB&#x2F;s。<br>(4) 标准传输率即在总线上每秒能传输的最大字节量，用 MB&#x2F;s 表示。例如，总线工作频率为33MHz，总线宽度为 32 位，则它最大的传输率为 132 MB&#x2F;s。<br>(5) 总线复用。通常地址总线与数据总线在物理上是分开的两种总线，地址总线传输地址码，数据总线传输数据信息。为了提高总线的利用率，可优化设计，让地址总线和数据总线共用一组物理线路，这称为总线的多路复用。<br>除了上述主要性能指标外，还有其他指标。例如，负载能力问题，由于不同的电路对总线的负载是不同的，即使同一电路板在不同的工作频率下，总线的负载也是不同的，因此，总线负载能力的指标不是太严格，通常用可连接扩充电路板数来反映总线的负载能力</p>
<p> 总带宽 &#x3D; 存储器总线频率 × 存储器总线位宽 × 存储器通道数 ÷ 8 </p>
</aside>

<h3 id="单总线结构："><a href="#单总线结构：" class="headerlink" title="单总线结构："></a><strong>单总线结构：</strong></h3><p>单总线结构将 CPU、主存及 I&#x2F;O 设备(通过 I&#x2F;O接口)都挂在一组总线上，支持I&#x2F;O设备与主存、I&#x2F;O 设备之间直接交换信息。</p>
<p>其结构简单，便于扩充，但因各部件共享一组总线，极易造成计算机系统的瓶颈现象。当I&#x2F;O 设备量很大时，总线发出的控制信号从一端逐个传送到第n个设备，它的传播延迟也会造成计算机系统工作效率的严重下降。</p>
<p><strong>为解决总线瓶颈问题，可采取增加总线宽度和提高传输速率等方法。</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled.png" alt="Untitled"></p>
<h3 id="双线结构："><a href="#双线结构：" class="headerlink" title="双线结构："></a><strong>双线结构：</strong></h3><p>单总线结构的缺陷是系统效率和连接到总线上的各设备的利用率不高。这是因为单总线不允许多于两台的设备在同一时刻交换信息。为了克服这一缺陷，可将 I&#x2F;O 总线与主存总线分开，形成了双总线结构。</p>
<p>这种总线结构有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送，另一条是I&#x2F;O 总线用于多个外围设备与通道之间进行数据传送，如图所示。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%201.png" alt="Untitled"></p>
<h3 id="三总线结构："><a href="#三总线结构：" class="headerlink" title="三总线结构："></a><strong>三总线结构：</strong></h3><p>三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这条总线分别是主存总线、I&#x2F;O总线和直接主存存取(Direct Memory Access，DMA)总线。</p>
<p>主存总线用于 CPU 和主存之间传送地址、数据和控制信息。I&#x2F;O 总线用于 CPU 和各类外围设备之间通信。DMA 总线用于主存和高速外围设备之间直接传送数据。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%202.png" alt="Untitled"></p>
<h3 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h3><ol>
<li><strong>机械特性</strong></li>
</ol>
<p>指总线的物理连接方式，包括总线的根数，总线的插头、插座的形状,引脚线的排列方式等。</p>
<ol>
<li><strong>功能特性：</strong></li>
</ol>
<p>描述总线中每根传输线的功能。例如，地址总线用来给存储器、IO 口编号，以便 CPU 按地址对其进行读写;数据总线是 CPU 和存储器、外设之间传送指令和数据的通道，其宽度反映了 CPU 一次处理和传送的二进制位数;</p>
<ol>
<li><strong>电气特性 :</strong></li>
</ol>
<p>定义每一根线上信号的传递方向及有效电平范围。其中，送入 CPU 的信号称为输入信号(IN)，从 CPU 发出的信号称为输出信号OUT)。</p>
<ol>
<li><strong>时间特性:</strong></li>
</ol>
<p>定义了每根线在什么时间有效。规定了总线上各信号有效的时序关系 CPU才能正确无误的使用。</p>
<aside>
❓ **CPU总线：**是计算机系统中最快的总线。这条总线主要由CPU使用，用来与高速缓存、主存和北桥之间传送信息。CPU总线是一个64位数据线和32位地址线的同步总线，时钟频率为66 MHz，100 MHz，133 MHz等。CPU是这条总线的主控者，但必要时可放弃总线控制权。
**PCI总线：**用于连接高速的I/O设备模块，如显卡、网卡、硬盘控制器等。PCI总线通过北桥与CPU总线连接，通过南桥与ISA总线相接。PCI总线是一个同步总线，32位（或64位）数据/地址线是同一组线，分时复用。
**ISA总线：**用于连接低速的I/O设备模块。主板上一般留有3～4个ISA总线扩充槽，以便使用各种16位/8位适配器卡。

</aside>

<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%203.png" alt="Untitled"></p>
<h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%204.png" alt="Untitled"></p>
<p>总线带宽指总线的最大数据传输率，即总线在进行数据传输时，单位时间内最多可传输的数据位数，通常用Mb&#x2F;s (Mbps)或MB&#x2F;s(MBps)表示。</p>
<p>总线的数据传输率可表示为:数据传输率&#x3D;总线宽度数据传输次数&#x2F;秒，数据传输次数&#x2F;秒又称为工作频率。注意，总线带宽的工作频率不考虑总线仲裁、地址传送等非数据传输操作的时间，而总线数据传输率的工作频率考虑总线所有操作的时间。<br>对于同步总线，总线带宽 B&#x3D;wXf&#x2F;m，其中，w 为总线宽度，f为总线时钟频率，m为一次数据传输所需的时钟周期数，f&#x2F;m 表示总线的工作频率。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%205.png" alt="Untitled"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%206.png" alt="Untitled"></p>
<h3 id="总线接口的基本概念"><a href="#总线接口的基本概念" class="headerlink" title="总线接口的基本概念"></a><strong>总线接口的基本概念</strong></h3><p>连接到总线上的设备都需要有一个接口电路，而不能直接把它的内部线路连接到总线上。总线上有一套信号线的定义，又有一套通信规则（又称协议），连接到总线上的信号都要符合总线的这些要求，总线还是各部件之间的连接界面，由于各部件之间存在各种差异，所以需要总线接口来弥补这些差异。</p>
<p>接口即I&#x2F;O设备适配器，具体指CPU和主存、外围设备之间通过总线进行连接的逻辑部件。接口在它连接的两个部件之间起着“转换器”的作用，以便实现彼此之间的信息传送。为了使所有的外围设备能够兼容，并能在一起正确地工作，CPU规定了不同的信息传送控制方法。一个标准接口可能连接一个设备，也可能连接多个设备。CPU、接口和外围设备之间的连接关系如图所示。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%207.png" alt="image.png"></p>
<p><strong>一个适配器必有两个接口</strong></p>
<p><strong>一是和系统总线的接口</strong>，<strong>CPU和适配器的数据交换一定的是并行方式；</strong></p>
<p><strong>二是和外设的接口</strong>，<strong>适配器和外设的数据交换可能是并行方式，也可能是串行方式。</strong></p>
<p><strong>根据外围设备数据传送方式的不同，适配器可分为串行数据接口和并行数据接口两大类。</strong></p>
<h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a><strong>总线控制</strong></h3><p>主要包括判优控制（或称仲裁逻辑）和通信控制</p>
<p>总线判优控制</p>
<p>总线上所连接的各类设备，按其对总线有无控制功能可分为主设备（模块）和从设备（模块）两种。只有获得总线使用权的主设备才能开始传送数据。</p>
<p>总线判优控制可分集中式和分布式两种，前者将控制逻辑集中在一处（如在CPU中），后者将控制逻辑分散在与总线连接的各个部件或设备上。</p>
<p><strong>（1）链式查询</strong></p>
<p>总线同意信号（BG）是<strong>串行</strong>地从一个I&#x2F;O接口送到下一个I&#x2F;O接口，如到达的接口无总线请求，则继续往下传；如到达的接口有总线请求，则不再往下传，这意味着该I&#x2F;O接口获得了<strong>总线使用权</strong>。<strong>BG信号就像一条链一样串联所有的设备接口，故这种总线控制方式称为链式查询方式。</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%208.png" alt="image.png"></p>
<p>在这种电路中，除一般数据总线D和地址总线A外，在控制总线中有三根线用于总线的控制，分别是<strong>总线忙（BS）线、总线请求（BR）线和总线同意（BG）线。</strong> </p>
<aside>
💡 **BS：**总线忙/闲状态线，当其有效时，表示总线正被某外设使用。

<p><strong>BR：</strong>总线请求线。当其有效时，表示至少有一个外围设备正在请求使用总线。</p>
<p><strong>BG：</strong>总线同意线。当其有效时，表示总线控制部件已响应总线请求（BR）。</p>
</aside>

<p><strong>（2）计时器定时查询</strong></p>
<p>工作原理是，总线上任一设备要求使用总线时，通过总线请求（BR）线发出总线请求信号，总线控制器接到请求信号后，在总线忙（BS）为复位的情况下，让计数器开始计数，计数值通过一组地址线发至各设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址一致时，该设备把总线忙（BS）置位，获得总线控制权。此时，中止计数器的计数及查询。</p>
<p>没有链式敏感：当某个设备的接口中有关键的电路出现故障时，不会影响期待设备使用总线</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%209.png" alt="image.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2010.png" alt="image.png"></p>
<p><strong>（3）独立请求方式</strong></p>
<p>这种总线控制方式中，每一个共享总线的设备均有一对<strong>总线请求（BR）和总线同意（BG）线</strong>。当设备要求使用总线时，便发出总线请求信号，总线控制部件中有一个排队电路，根据一定的优先次序决定首先响应哪个设备的请求，当请求的设备排上队，便收到总线同意（BG）信号，从而可以使用总线。</p>
<p>优点：对优先次序的控制也相当地灵活，它可以预先固定优先次序，也可以通过程序来改变优先次序，并且在必要时屏蔽某些设备的请求。</p>
<p>缺点：控制器复杂</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2011.png" alt="image.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2012.png" alt="image.png"></p>
<p><strong>2、分布式判优控制</strong></p>
<p>分布式控制不需要中央仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当某一个或多个功能块有总线请求时，把它们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号大，则它的总线请求不予响应，并撤销它的仲裁号。</p>
<p>最后，获胜者的仲裁号保留在仲裁总线上。</p>
<p><strong>仲裁比较</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2013.png" alt="image.png"></p>
<h3 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a><strong>总线通信</strong></h3><p>总线的一次信息传送过程，大致可分为如下几个阶段：<strong>请求总线，总线仲裁，寻址，信息传送，状态返回。</strong></p>
<p>请求总线：由需要使用总线的主设备提出请求。</p>
<p>总线仲裁：总线仲裁机构决定将下一传输周期的总线使用授权于某一主设备。</p>
<p>寻址： 取得了使用权的主设备通过总线发出本次要访问的从设备的地址及有关命令，启动参与本次传输的从设备。</p>
<p>信息传送： 主设备和从设备进行数据交换，数据由源设备发出，经数据总线流入目的设备。</p>
<p>状态返回： 主设备的有关信息均从总线上撤除，让出总线使用权。</p>
<p><strong>1、同步通信：</strong><br>总线上的设备（或部件）通过总线进行信息传送时，用一个公共的时钟信号进行同步，这种方式称为同步通信。这个公共的时钟信号可以由总线控制部件发送到每一个设备（或部件），也可以每个设备（或部件）有自己的时钟发生器，但是都必须由CPU发出的时钟信号进行同步。由于采用统一的时钟，每个设备（或部件）发送信息或接收信息都在固定的总线传送周期中，一个总线传送周期结束，开始下一个总线传送周期。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2014.png" alt="image.png"></p>
<p>如上图表示某个输入设备向CPU传输数据的同步通信过程。总线传输周期是连接在总线上的两个部件完成一次完整且可靠的信息传输时间，它包含4个时钟周期T1，T2，T3和T4。同步通信在系统总线设计时，对T1，T2，T3，T4都有明确且唯一的规定：T1主设备发地址；T2主设备发读命令；T3从设备提供数据；T4主设备撤销读命令，从设备撤销数据。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2015.png" alt="image.png"></p>
<p>对于写命令，其传输周期为：<strong>T1主设备发地址；T1主设备提供数据；T2主设备发出写命令</strong>，从设备接收到命令后，必须在规定时间内将数据总线上的数据写到地址总线所指明的单元中；<strong>T4主设备撤销写命令和数据</strong>。写命令传输周期的时序如图所示。</p>
<aside>
💡

<p>同步通信的优缺点：</p>
<p>优点是具有较高的传输速率，数据传输速度快，总线控制逻辑也比较简单。同步通信适用于总线长度较短，各部件存取时间比较接近的情况。<br>缺点是控制线的数量多，例如，要控制n个设备，必须有n根总线请求线和n根总线同意线，相比之下，链式查询方式只需1根总线请求线和1根总线同意线。另外，独立请求方式的控制器也要复杂得多。</p>
</aside>

<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2016.png" alt="image.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2017.png" alt="image.png"></p>
<p><strong>2、异步通信：</strong><br>利用数据发送设备和数据接收设备之间的相互“握手”信号来实现总线数据传送的方式称为异步通信。在异步通信中，没有统一的时钟，也没有固定的时间问题，完全依靠传送双方相互制约的“握手”信号来实现定时控制，把交换信息的两个设备（或部件）分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p>
<aside>
💡 **异步通信的优缺点：**

<ol>
<li>优点是总线周期长度可变，能保证两个工作速度相差很大的设备（或部件）之间可靠地进行信息交换，自动适应时间的配合。</li>
<li>缺点是比同步通信复杂，速度也较慢。</aside></li>
</ol>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2018.png" alt="image.png"></p>
<p><strong>（1）不互锁方式。</strong><br>主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系，如图所示。</p>
<p><strong>（2）半互锁方式。</strong><br>主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图所示。</p>
<p><strong>（3）全互锁方式。</strong><br>① 主设备发出“请求”信号，等待从设备的“应答”信号； ② 从设备接到“请求”信号后，发出“应答”信号——一次握手； ③ 主设备接到从设备的“应答”信号，就撤销其“请求”信号——二次握手； ④ 从设备在获知主设备已撤销“请求”信号后，随即撤销其应答信号——三次握手。 这样，经过三次握手在通信双方建立了完全的互锁关系，如图所示。</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2019.png" alt="image.png"></p>
<p><strong>3、半同步通信：</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2020.png" alt="image.png"></p>
<p><strong>4、分离式通信：</strong></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/image%2021.png" alt="image.png"></p>
<p><strong>5、总线数据传送模式</strong><br>当代的总线标准大都能支持以下4类模式的数据传送。</p>
<p>（1）读、写操作。<br>读操作是由从方到主方的数据传送；写操作是由主方到从方的数据传送。一般，主方先以一个总线周期发出命令和从方地址，经过一定的延时再开始数据传送总线周期。为了提高总线利用率，减少延时损失，主方完成寻址总线周期后可让出总线控制权，以使其他主方完成更紧迫的操作。然后再重新竞争总线，完成数据传送总线周期。</p>
<p>（2）块传送操作。<br>只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入。对于CPU（主方）、存储器（从方）而言的块传送，常称为猝发式传送，其块长一般固定为数据线宽度（存储器字长）的4倍。</p>
<p>（3）写后读、读后写操作。<br>只给出地址一次，或进行先写后读操作，或进行先读后写操作。前者用于校验目的，后者用于多道程序系统中对共享存储资源的保护。这两种操作和猝发式操作一样，主方掌管总线直到整个操作完成。</p>
<p>（4）广播、广集操作。<br>一般而言，数据传送只在一个主方和一个从方之间进行。但有的总线允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集，它将选定的多个从方数据在总线上完成AND或OR操作，用以检测多个中断源。</p>
<p><strong>六、常见问题和易混淆知识点</strong><br>同一个总线是否能既采用同步通信又采用异步通信 半同步通信总线可以。</p>
<p>这类总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。</p>
<p>一个总线在某一时刻是否可以有多对主从设备进行通信 不可以。</p>
<p>在某一总线周期内，总线上只有一个主设备控制总线。</p>
<p><strong>七、本章总结</strong><br>1、总线是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通道，并在争用资源的基础上进行工作。</p>
<p>2、总线有物理特性、功能特性、电气特性、机械特性，因此必须标准化。衡量总线性能的重要指标是总线带宽，它的定义为总线本身所能达到的最高传输速率。</p>
<p>3、计算机系统中，根据应用条件和硬件资源不同，信息的传输方式可采用串行传送，并行传送和分时传送。</p>
<p>4、总线仲裁是总线系统的核心问题之一。为了解决多个主设备同时竞争总线控制权的问题，必须具有总线仲裁部件。</p>
<p>5、总线通信是总线系统的又一核心问题之一。为了同步主方、从方的操作，必须制订通信协议，通常采用同步通信与异步通信两种方式。</p>
<p>6、目前，典型的总线标准有ISA，EISA，VESA，PCI，PCI-Express，AGP，RS-232C，USB等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送</p>
<h2 id="（4）存储器"><a href="#（4）存储器" class="headerlink" title="（4）存储器"></a>（4）存储器</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/3a7493da074bcbbe63b510666f063ad6.png" alt="3a7493da074bcbbe63b510666f063ad6.png"></p>
<p><strong>按存储介质分类：</strong></p>
<ol>
<li><p>半导体存储器：</p>
<p> 由半导体器件组成的存储器，当电源消失时，所存储信息随之消失，为一种<strong>易失性</strong>存储器，其优点是<strong>体积小、功耗低、存取时间短</strong>。用非挥发性材料制成的半导体存储器克服了信息易失的弊病。</p>
<p> 按照材料的不同：</p>
<ul>
<li>双极型（TTL）半导体存储器：工作速度快，与CPU处在同一量级，但是集成度低、功耗大、价格偏高</li>
<li>MOS半导体存储器：高集成度，制造简单，价格低廉，功耗小，但是速度较双极型器件慢</li>
</ul>
</li>
<li><p>磁表面存储器</p>
<p> 在金属或塑料基体的表面涂上一层磁性材料作为记录介质，工作时磁层随载体高速运转，磁头在磁层上进行读写操作，按照剩磁状态的不同而区分”0”和”1”，具有非易失的特点</p>
<p> 磁表面存储器分类（按照载磁体形状不同）：</p>
<ul>
<li>磁盘</li>
<li>磁带</li>
<li>磁鼓（已经基本不使用了）</li>
</ul>
</li>
<li><p>磁芯存储器</p>
<p> 由硬磁材料做出的环状元件，在磁芯中穿有驱动线（通电流）和读出线，这样就可以进行读&#x2F;写操作，磁芯为磁性材料，所以也是一种非易失的永久记忆存储器</p>
<p> 由于体积过大，工艺复杂，功耗大，于是已经基本不使用了</p>
</li>
<li><p>光盘存储器</p>
<p> 应用激光在记录介质（磁光材料）上进行读&#x2F;写的存储器，具有非易失性的特点。</p>
</li>
</ol>
<p><strong>按存取方式分类：</strong></p>
<p><strong>随机存取存储器（RAM，Random Access Memory）</strong></p>
<p>也被称为随机存储器或者读写存储器，存取时间和存储单元的物理地址无关，为一种可读&#x2F;写存储器，在存储器的任何一个存储单元的内容都可以随机存取，存取的时间和存储单元的物理位置无关（计算机的主存都采用这种随机存储器。一般的RAM芯片，关闭电源以后所存信息将全部丢失，故RAM常用来暂存运行的程序和数据。高速缓冲存储器Cache就是使用高速的静态RAM组成的小容量存储器<br><strong>随机存储器分类（按照存储原理的不同）</strong></p>
<ul>
<li>静态RAM：以触发器原理寄存信息</li>
<li>动态RAM：以电容充放点原理寄存信息</li>
</ul>
<p><strong>只读存储器（ROM，Read Only Memory）</strong></p>
<p>早期的ROM因为技术不成熟所以无法擦写，出厂后就只能读数据，所以叫只读存储器，即一但存储了原始信息以后，在程序执行的过程中，只能将内部信息读出，无法随意改变原始信息。掉电以后所存信息不会丢失，故ROM通常将其用来存放固定不变的程序、常数、汉字字库，甚至用来进行操作系统的固化，ROM的内容是由生产厂家或者用户使用专用设备写入固化的。存数据的时间和存储单元的物理位置无关。只读存储器和随机存储器可共同作为主存的一部分，统一构成主存的地址域</p>
<p>硬盘和ROM的关系<br>由于ROM和硬盘都可以存储数据而且断电不会丢失，而且都广泛运用于电子产品中，所以很容易对两者产生混淆，这里进行一个大概的区分：硬盘分为两种，一种是机械硬盘（即磁盘HDD）,一种是固态硬盘（SSD），机械硬盘和ROM没什么关系，但是固态硬盘用到的存储颗粒基于NAND FLASH闪存技术，该技术ROM技术发展的产物，所以说硬盘和ROM还是多多少少有些关系的，但不能说ROM就是硬盘<br><strong>只读存储器分类（根据用户需求不同而制造的不同只读存储器）</strong></p>
<ul>
<li>掩模型只读存储器（MROM）</li>
<li>可编程只读存储器（PROM）</li>
<li>可擦除可编程只读存储器（EPROM）</li>
<li>用电可擦除可编程只读存储器（EEPROM）</li>
</ul>
<p><strong>串行访问存储器</strong></p>
<p>对存储单元进行读&#x2F;写操作时，需要按照存储单元的物理位置的先后顺序寻找地址，根据信息所在物理位置的不同，存取时间会有所差异，即存取的时间和存储单元的物理地址相关</p>
<p><strong>串行访问存储器分类（根据访问数据的方式不同）</strong></p>
<ul>
<li>顺序存取存储器：无论信息处在哪里，读&#x2F;写必须从其介质的始端开始顺序访问，比如，磁带存储器的读&#x2F;写过程</li>
<li>直接存取存储器：整个读&#x2F;写过程的前段为直接访问，后段为顺序访问，比如对磁盘进行读&#x2F;写时，首先直接指出该存储器中的某一个区域（即磁道），然后再开始进行顺序访问</li>
</ul>
<p><strong>按在计算机中的作用不同：</strong></p>
<p>存储器主要分为主存储器、辅助存储器、缓冲存储器。</p>
<p>一个熟悉的缓冲存储器就是高速缓冲存储器Cache（一般使用静态RAM构成），速度高于主存</p>
<p><strong>缓存Cache和缓冲区buffer的区别</strong></p>
<p>1、缓冲区属于内存空间，是内存空间的一部分。我们在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据（就像人落地的时候，需要进行一个缓冲一样，数据的传递也需要一个缓冲），然后我们把这部分预留的空间就叫做缓冲区</p>
<p><strong>buffer的全称其实为buffer cache，偏重于写，一般被称为写缓存write cache</strong></p>
<aside>
❓ 在没有加入缓冲区概念的时候，应用程序都是直接将内存中的数据传递给硬盘空间，但是由于内存相对于硬盘来说，速度极快，这样整体数据传递的速率就会因为硬盘速率低而过慢，导致内存中的应用程序效率过低

<p>在加入缓冲区的概念后，应用程序可以先将数据交给同在内存中的缓冲区，然后就可以执行其他任务（由于同在内存中，所以这个数据传递过程是极快的），在缓冲区中将要写入硬盘的数据暂存下来后再将缓冲区中的数据传递给硬盘空间，等缓冲区的数据取完后再次进行缓冲区的数据填充，这样就可以减少磁盘的读写次数，所以应用缓冲区可大大提高计算机的运行速度（比如原来是每秒要写100次硬盘，对系统冲击很大，此时用缓冲区将数据暂存起来，就会变成每10秒写一次硬盘，对系统的冲击就很小，写入效率也高了）</p>
</aside>

<p>2、CPU中的Cache的中文名称是高速缓冲存储器。根据程序的局部性原理，当计算机执行程序时，数据与地址管理部件会预测可能要用到的数据和指令，并将这些数据和指令预先从内存中读出送到Cache。一旦需要时，先检查Cache，若有就从Cache中读取，若无再访问内存。Cache就是用来解决CPU与内存之间速度不匹配的问题，避免内存与辅助内存频繁存取数据，这样就提高了系统的执行效率<br><strong>cache偏重于读，一般被称为读缓存read cache</strong></p>
<p><strong>主存可以和CPU直接交换信息</strong>；</p>
<p><strong>闪速存储器（Flash Memory）</strong></p>
<p>为半导体存储器，速度高于磁盘，低于主存，可以在主存和辅存之间实现二者速度的弥补，起缓冲作用，U盘就是使用闪速存储器制作的，闪速存储器可以在一些高性能计算机中作为硬盘</p>
<p>实际上，闪速存储器是在只读存储器EPROM和EEPROM的工艺基础上产生的一种新型，可靠性更高的可擦非易失性存储器，具有整片擦除的特点，对于需要周期性修改存储信息的应用场合，闪速存储器为一个极其理想的器件，因为其至少可以擦除&#x2F;编程10000次</p>
<p>辅存是主存的后援存储器，用来存放当前暂时不用的程序和数据，<strong>它不能与CPU直接交换信息</strong>，两者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。</p>
<p>缓存用来两个速度不同的部件之中。</p>
<h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a><strong>存储器的层次结构</strong></h3><p>存储器具有三个性能指标：速度，容量，每位价格。一般来说速度越高，位价越高；容量越大，位价越低；容量越大，速度必然越低</p>
<p>由存储器的性能指标之间的关系，可见人们追求的大容量、高速度、低位价的存储器是很难实现的，于是我们提出了存储器的层次结构，来尽可能解决这个矛盾</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%207.png" alt="Untitled"></p>
<p>该图中，由上至下，存储器价位越来越低，速度越来越慢，容量越来越大，CPU访问的频度也越来越少</p>
<ul>
<li>最上层的寄存器通常制作在CPU芯片内部，存储的数据直接在CPU内部参与运算，这里，可能要补充一些知识：寄存器不仅仅存在于CPU内部，I&#x2F;O端口中也会有寄存器存在。对于有些寄存器，指令对于这些寄存器是可以直接操作的，而且这些寄存器对于机器语言程序员来说并不是透明的，称为体系结构寄存器</li>
<li>中间的主存用来存放将要参与运行的程序和数据，速度与CPU相差较大（而且是剪刀差），为了进行速度匹配，添加了一个高速缓存Cache，现代计算机将Cache也制作在CPU内部</li>
<li>下层的磁盘、磁带属于辅助存储器，容量比内存大得多，用来存放暂时未被使用的程序和数据，CPU不能直接访问辅存，辅存只能和主存交换信息，因此辅存的速度可以比主存慢得多</li>
</ul>
<h3 id="存储器的存储层次"><a href="#存储器的存储层次" class="headerlink" title="存储器的存储层次"></a><strong>存储器的存储层次</strong></h3><p>存储体系：指使用两种或者两种以上的存储介质，用软件、硬件、或者是软硬件相结合的方式将它们链接成一个统一的整体，使得从某一级程序员的角度出发，这个整体（即表明对于程序员来说这个整体是透明的）具有高速度、大容量、低价格的特点</p>
<p>缓存-主存这一层次的速度接近于缓存，而容量和价位却接近于主存<br>主存-辅存这一层次的速度接近于主存，而容量和价位却接近于辅存<br>于是可以发现，这样的缓存、主存、辅存三级结构（由两个存储体系构成）解决了前面提到的矛盾，现代计算机系统几乎都具有这两个存储层次</p>
<p><strong>1、缓存-主存</strong></p>
<p>主要解决CPU和主存速度不匹配的问题，于是采用硬件的方法把缓冲主存链接为一个存储体系</p>
<p>解决方式：由于缓存的速度比主存高，于是只要将CPU近期要调用的信息存入缓存（使用了程序的局部性原理），CPU即可直接从速度较快的缓存中获取信息，提高了访存速度。但是同时由于缓存的容量较小，于是需要不断地将主存的数据存入缓存中，使缓存原来的数据被替换掉，这个过程是硬件自动完成的，对程序员来说是透明的</p>
<p><strong>2、主存-辅存</strong></p>
<p>主要解决存储系统容量的问题，于是采用软硬件相结合的方法把主存辅存链接为一个存储体系</p>
<p>解决方式：辅存的容量比主存大得多，当CPU需要辅存中的数据时，再将辅存的信息存入主存，供CPU直接访问，主存和辅存之间的信息调动是由硬件和操作系统共同完成的</p>
<p><strong>虚拟存储系统（Virtual Memory，VM）</strong></p>
<p>虚拟存储器是为了满足用户对存储空间不断增长的需求而提出的一种计算机存储器管理技术，它是建立在主存-辅存这一物理层次结构基础之上，由辅助硬件及操作系统存储管理软件组成的一种存储体系。在这个存储系统中，程序员编写的程序的地址范围与虚拟存储器的地址空间相对应，即程序员编程的时候，可用的地址空间是远远大于主存空间的</p>
<p>虚地址</p>
<p>虚拟存储器的存储单元个数远远大于主存的实际存储单元个数，所以用户编程使用的不是实际地址，而是比实际地址位数更长的地址，这种地址是面向程序需要，而不需要考虑所编程序将来在主存中的实际地址，我们一般称这些虚拟存储器的存储单元对应的地址码为虚地址（虚存地址、虚拟地址、逻辑地址），虚地址从0开始。CPU可以访问的虚地址空间，甚至可以达到整个辅存容量</p>
<p>实地址<br>我们把主存各个存储单元实际存在的地址称为实地址（物理地址），物理地址才是程序在执行过程中真正能够访问的地址</p>
<p>虚实地址的转化</p>
<p>虚地址转变为实地址的工作是由计算机系统的硬件和操作系统自动完成的，对程序员是透明的。当虚地址的内容就在主存中时，则通过地址变换机制，将虚地址转换为实地址，然后访问主存的实际单元；当虚地址的内容不在主存中时，则要先将虚地址的内容传递到主存中的合适单元后，再让机器使</p>
<p>对虚拟存储器的直观描述（可能并不那么正确）</p>
<p>当物理内存（就是你的内存条）不够的时候，在硬盘上借用一块空间当内存来用，但是由于这块空间不是物理内存提供的，所以会将这部分硬盘空间称为”虚拟内存”（Windows系统的虚拟内存大小可以进行人为设置，Linux系统中的SWAP（交换分区）也是一个虚拟内存）<br>由于虚拟内存实际是硬盘中的空间，所以其相同空间的价格要比物理内存低廉，而容量也是以GB为初始单位<br>执行的程序只会向操作系统申请空间，不会考虑物理内存是否足够大<br>由于硬盘传输的速度要比内存传输速度慢的多，所以虚拟内存比物理内存的效率要慢得多<br>断电后数据丢失。和物理内存一样，在电脑遇到突然断电后，虚拟内存中的数据就会丢失，不像我们平时的硬盘（外部存储器）断电还有保存功能</p>
<h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a><strong>主存储器</strong></h3><p><strong>主存储器内部组成的细化</strong></p>
<p>实际上，根据MAR中的地址访问某一个存储单元时，存储器内部还需要经过地址译码、驱动等电路的运行，才能找到所需访问的存储单元。将地址线接入译码器，从译码器输出端接出的线称为选择线，用于选定译码器指定的存储单元</p>
<p>读出数据时，存储器内部还必须经过读出放大器，才能将被选中的存储单元中的存储字送到MDR中；写入时，必须经过写入电路，才能将数据写入被选中的存储单元中</p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%208.png" alt="Untitled"></p>
<h3 id="主存储器与CPU的联系"><a href="#主存储器与CPU的联系" class="headerlink" title="主存储器与CPU的联系"></a><strong>主存储器与CPU的联系</strong></h3><ul>
<li>物理上的联系<ul>
<li>现代计算机的主存都由半导体集成电路构成，驱动器，译码器以及读写电路均制作在存储芯片中，而MAR和MDR则制作在了CPU中（在后续介绍CPU内部结构的时候，就会体现这一点），存储芯片和CPU芯片使用系统总线相连接</li>
</ul>
</li>
<li>功能上的联系<ul>
<li>当要从主存储器中读出某一信息字时，首先由CPU将该字的存储地址发送给MAR，通过地址总线，主存接收到地址，CPU发送读命令，主存将该存储单元的信息字读出，放在数据总线上，读操作完成<br>  当要向主存储器存入某一信息字时，首先由CPU将该字的存储地址发送给MAR，通过地址总线，主存接收到地址，CPU发送写命令，主存将数据总线上的信息字写入对应的存储单元中，写操作完成</li>
</ul>
</li>
</ul>
<h3 id="主存储器中存储单元地址编号的分配方式"><a href="#主存储器中存储单元地址编号的分配方式" class="headerlink" title="主存储器中存储单元地址编号的分配方式"></a><strong>主存储器中存储单元地址编号的分配方式</strong></h3><p>不同的机器，存储字长也不同，为了满足字符处理的需要，常用8位二进制表示一个字节，同时存储字长都设定为8的倍数。计算机系统既可以按照字（即存储字长）进行寻址，也可以按照字节进行寻址，即可以使用字地址和字节地址两种地址实现存储器中数据的定位</p>
<p>下面使用大端存储和小端存储两种不同的方式存储同一个十六进制数12345678为例（注意1为最高位，8为最低位）对主存储器存储单元地址的分配方式进行进一步的展示（这里的”大端存储和小端存储”中的”大端”和”小端”即为文章——C语言存储篇中提到的”大端”和”小端”的概念）</p>
<ul>
<li><p>大端（大尾）存储方式</p>
<p>  将一个存储单元的高位字节地址作为该存储单元地址的数据存储方式</p>
<p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%209.png" alt="Untitled"></p>
</li>
<li><p>小端（小尾）存储方式</p>
<p>  将一个存储单元的低位字节地址作为该存储单元地址的数据存储方式</p>
<p>  <img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%2010.png" alt="Untitled"></p>
</li>
</ul>
<h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a><strong>主存的技术指标</strong></h3><p><strong>存储容量</strong></p>
<p>指主存可以存储的二进制代码的总位数，即<strong>存储容量&#x3D;存储单元个数 * 存储字长</strong>，计算出的存储容量的单位为”位”（容量也可以使用字节总数来表示，即<strong>存储单元个数*存储字长&#x2F;8</strong>，计算出的存储容量的单位为MB，GB，TB等单位）</p>
<p><strong>存储速度</strong></p>
<p>存储速度是由存取时间和存取周期来表示的</p>
<ul>
<li>存取时间<br>又称为存储器的访问时间，是指从启动一次存储器操作（指读&#x2F;写）一直到完成该操作所需要花费的全部时间，所以存取时间分为读出时间和写入时间两种<ul>
<li>读出时间：从存储器接收有效地址开始，到产生有效输出所需的全部时间</li>
<li>写入时间：从存储器接收到有效地址开始，到数据写入被选中单元为止所需要的全部时间</li>
</ul>
</li>
<li>存取周期<ul>
<li><strong>指存储器连续进行两次独立的存储器操作（比如，两次读操作）所需的最小时间间隔（对一个存储单元进行第一次操作开始到完成对第二个存储单元的第二次操作之间的最小间隔）</strong>，通常来说，存取周期要大于存取时间。存取周期和存储器带宽紧密联系，存储器带宽是以存储器为中心的机器改善机器瓶颈的一个关键因素</li>
<li>存储器带宽<ul>
<li>表示单位时间内存储器存取的信息量，单位可以使用字&#x2F;秒或者字节&#x2F;秒或者位&#x2F;秒来表示</li>
<li>提高存储器带宽的措施：1、缩短存储周期 2、增加存储体 3、增加存储字长，使每一个存取周期可以读&#x2F;写更多的二进制位数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>半导体存储芯片</strong></p>
<p>半导体存储芯片采用超大规模集成电路制造工艺，在一个芯片内部集成具有记忆功能的存储矩阵、译码驱动电路和读&#x2F;写电路等（与存储器相关的MAR和MDR制作在了CPU中）</p>
<p><strong>半导体存储芯片的基本结构</strong></p>
<p>存储矩阵</p>
<p>用于存储0、1代码的一块区域</p>
<p>译码驱动</p>
<p>负责把通过地址总线送来的地址信号翻译成对应存储单元的选择信号，该选择信号在读&#x2F;写电路的配合下即可实现对被选中存储单元的读&#x2F;写操作，即存储器的译码驱动</p>
<p>读&#x2F;写电路</p>
<p>包括放大器和写入电路，用来完成CPU对存储芯片的读&#x2F;写操作</p>
<p>总线</p>
<p>存储芯片通过地址总线、数据总线和控制总线与外部连接</p>
<p>地址线和数据线的位数共同反映了存储芯片的容量（类比于MAR和MDR的位数共同反映了存储体的容量），比如地址线有10根，数据线有4根，则芯片容量为（ 2^10 ）* 4，通常使用1K * 4这样的形式来表示芯片容量（4表示的是数据线个数，即存储字长的位数，1K表示的存储单元总数，每一个地址对应一个字节的空间）</p>
<ul>
<li><p>地址总线</p>
<ul>
<li><p>为单向输入总线，</p>
<p>  地址总线的位数与存储芯片的存储单元总数和地址总数有关</p>
</li>
</ul>
</li>
<li><p>数据总线</p>
<ul>
<li><p>为双向输入输出总线（有的芯片也会使用成对的数据线分别作为输入和输出），</p>
<p>  数据总线的位数和存储芯片一次可以读出或者写入的数据位数有关</p>
</li>
</ul>
</li>
<li><p>控制总线</p>
<ul>
<li>读&#x2F;写控制线<ul>
<li>单向输入总线，用于CPU对存储芯片实现读&#x2F;写操作</li>
<li>可以使用一根线进行控制：WE表示低电平尾写操作，高电平为读操作</li>
<li>可以使用两根线分别进行控制： OE表示进行读操作； WE表示进行写操作；</li>
</ul>
</li>
<li>片选线<ul>
<li>用来选择芯片（半导体存储器中具有许多芯片），指出本次访存操作的目标地址针对的是具体是哪个芯片</li>
<li>半导体存储芯片的片选线一般有两种标识方式，一个是CS，表示是否选择该芯片，一个是 CE，表示该芯片是否使能，皆为低电平有效</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.27.35.png" alt="截屏2024-09-04 00.27.35.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.32.14.png" alt="截屏2024-09-04 00.32.14.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.32.27.png" alt="截屏2024-09-04 00.32.27.png"></p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.32.40.png" alt="截屏2024-09-04 00.32.40.png"></p>
<p><strong>片选线工作的例子：</strong></p>
<p>如果使用 16K x 1位 的存储芯片要组成 64K x 8位 的存储器</p>
<p>由于存储器中的每一个存储单元的容量为8位（一个字节），而存储芯片的存储单元的容量为1位，于是我们要将8个存储芯片看作一组，在进行存储器读&#x2F;写操作的时候，必须要同时对绑定为一组的这8个存储芯片同时进行读&#x2F;写操作，此时每一组芯片的容量为 16K X 8位，由于64为16的4倍，所以还需要增加4组这样的 16K x 1位 芯片才能满足要求，形成一个 64K X 8位 的存储器</p>
<p>进行地址编号分配的时候，由于同一组的8个芯片要同时工作，所以每一组共用地址数目为16K的地址编号和一根片选线（8个芯片要么全部被选中，要么全部都不被选中）。比如，当我们需要地址编号为65535（64K-1）对应存储器中的数据时，我们就会将该地址编号对应的那一组的8个存储芯片的片选信号同时置为低电平（8个存储芯片同时处于有效状态），同时其他组的芯片的片选信号全部置为高电平（其他存储芯片同时处于无效状态），从而实现仅仅对此组的8个芯片同时进行存储单元进行访问（在8个芯片相对应的同一位置的那个存储单元处同时读出一位，从而取出地址编号为65535对应存储器中的那8位数据）<br><strong>译码驱动方式（选中芯片中某一个存储单元）</strong></p>
<p><strong>线选法</strong></p>
<p>数据线有8根，表示每一个存储单元的位数有8位（一个字节）；地址线有4根，表示每一个存储单元的总数为16个，所以存储容量表示为16 * 1字节</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%2011.png" alt="Untitled"></p>
<p><strong>选中存储单元的方式</strong></p>
<ul>
<li>使用一根字选择线（字线），可以选中一个存储单元的所有二进制位（比如选中了一个字节，8个比特位）</li>
<li>比如，当地址线A3 A2 A1 A0分别为1 1 1 1时，地址译码器输出端的第15根字线有效，这一根线选中的那最后一个存储单元的8位数据就可以直接进行读&#x2F;写</li>
</ul>
<p>特点</p>
<ul>
<li>这种选中存储单元的方式结构简单，但是只适用于容量不大的存储芯片的驱动，如果地址单元数目过多，就会导致译码器输出端上连接的线数将会非常多，线路非常密集</li>
<li>比如有20根地址线，采用线选法，我们需要一个译码器进行译码，这样就需要在译码器的输出端连接1M根线，每一根线对应一个存储单元</li>
<li>本质上来说，线选法是将所有的存储单元排成一列（类似于C语言中一维数组的各个元素空间在内存中的存储方式）</li>
</ul>
<p><strong>重合法</strong></p>
<p>数据线只有一根，表示每一个存储单元的位数只有一位；地址线有10根，表示每一个存储单元的总数为 1K 个，所以存储容量表示为 1K * 1位</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/%25E6%2588%25AA%25E5%25B1%258F2024-09-04_00.36.45.png" alt="截屏2024-09-04 00.36.45.png"></p>
<p>选中存储单元的方式</p>
<p>对于图中的矩阵，使用了64根线（X，Y两个方向的译码器输出端各具有32根），与线选法不同的是此时每一个存储单元具有行、列两个地址，通过确定行、列地址，即可实现对该 32X32 矩阵的中每一个存储单元的访问（只有当一个存储单元的行地址和列地址都被选中时，才能对该存储单元进行访问）</p>
<p>比如，当地址线全为 0 的时候（即A9 A8 … A0全部为0），两个译码器输出 X0 和 Y0 有效，对应于矩阵中 0 行 0 列的那个存储单元被选中，只有这个存储单元才能进行数据的输入和输出<br>特点</p>
<p>实际上，在重合法中，在进行读操作的时候，被选中的行和列中的其他存储单元，自身也会进行数据输出，但是都不会到达I&#x2F;O读写结构处，只有当一个存储单元的行地址和列地址都被选中时，才能让存储单元中的数据成功到达I&#x2F;O读写结构处。类似地，进行写操作的时候也是因为是否具有通路的问题，而导致只有那个行地址和列地址同时被选中的那个存储单元，才能实现数据的输入</p>
<p>比如有20根地址线，采用重合法，我们需要两个译码器进行译码，这两个译码器的输入端分别连接10根地址线，则在译码器的输出端一共就可以产生2K根线，每两根相互垂直的线即可选中一个存储单元，这种方式相对于线选法节省了大量的线</p>
<p>本质来说，重合法是将所有的存储单元排成一个矩阵，只有将行地址和列地址进行组合，才是一个存储单元的完整地址</p>
<p>使用重合法进行存储单元选定的例子：</p>
<p>如何使用重合法实现一个容量为 1K X 4位 的存储器</p>
<p>一个 1K x 4位 的存储器表示每一个存储单元的位数为4，即我们要把4个基本单元电路（每一个基本单元电路本身可以存储一位比特位的数据）作为一组，同时要实现一根列线控制4个基本单元同时读&#x2F;写有效，此时1K表示具有1024（210）个存储单元，又每一个存储单元为4位，于是需要26*26个基本单元电路（一个相互垂直的线选中一个基本单元电路）<br>那么我们可以将这些基本单元电路排布为一个 64 x 64 的矩阵，由于要实现的是一个列选信号同时控制4个基本单元电路，于是我们对应列地址的译码采用4个输入端，16个输出端的译码器，实现每一个输出端控制4列，而行地址依旧使用6个输入端，64个输出端的译码器，这样就可以实现：只要给出一个地址编号，就会同时有4个基本单元电路被选中</p>
<p><img src="/../%E8%AE%A1%E7%BB%84%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2072618aae149c4fc9ba773ba965600e88/Untitled%2012.png" alt="Untitled"></p>
<p><strong>随机存储器（RAM）</strong></p>
<p><strong>静态RAM（SRAM）</strong></p>
<p><strong>静态RAM基本单元电路</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">heguang123456</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">http://example.com/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="数据库系统概论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">数据库系统概论</div></div></a><a class="next-post pull-right" href="/2024/09/24/part1/" title="测试文章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">测试文章</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">heguang123456</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">计算机组成原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">1. 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA"><span class="toc-number">2.1.</span> <span class="toc-text">（1）计算机系统概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.3计算机的工作步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">（2）计算机的发展史及应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">2. 计算机系统的硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF"><span class="toc-number">3.1.</span> <span class="toc-text">（3）系统总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF"><span class="toc-number">3.1.1.</span> <span class="toc-text">系统总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF"><span class="toc-number">3.1.2.</span> <span class="toc-text">通信总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">单总线结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BA%BF%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">双线结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">3.1.5.</span> <span class="toc-text">三总线结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.6.</span> <span class="toc-text">总线的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">3.1.7.</span> <span class="toc-text">总线性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.8.</span> <span class="toc-text">总线接口的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.9.</span> <span class="toc-text">总线控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.10.</span> <span class="toc-text">总线通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">（4）存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">存储器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">存储器的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1"><span class="toc-number">3.2.3.</span> <span class="toc-text">存储器的存储层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">主存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">3.2.5.</span> <span class="toc-text">主存储器与CPU的联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E7%BC%96%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.6.</span> <span class="toc-text">主存储器中存储单元地址编号的分配方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">3.2.7.</span> <span class="toc-text">主存的技术指标</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" title="数据库系统概论">数据库系统概论</a><time datetime="2024-09-27T06:56:06.000Z" title="Created 2024-09-27 14:56:06">2024-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-09-26T22:11:58.000Z" title="Created 2024-09-27 06:11:58">2024-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/24/part1/" title="测试文章">测试文章</a><time datetime="2024-09-24T02:30:41.398Z" title="Created 2024-09-24 10:30:41">2024-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/24/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/" title="博客维护">博客维护</a><time datetime="2024-09-24T02:25:35.298Z" title="Created 2024-09-24 10:25:35">2024-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/24/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2%E7%9A%84%E5%AD%A6%E6%9C%AF%E8%AF%9A%E4%BF%A1-%E5%AD%A6%E7%94%9F%E6%89%8B%E5%86%8C/" title="学生手册">学生手册</a><time datetime="2024-09-23T19:29:56.000Z" title="Created 2024-09-24 03:29:56">2024-09-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By heguang123456</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>